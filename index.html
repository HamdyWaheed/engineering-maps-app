<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <!-- قسم البيانات الوصفية والإعدادات الأساسية للصفحة -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>تطبيق الخرائط الهندسية - تطوير م. حمدي وحيد</title>
    
    <!-- قسم استيراد المكتبات والخطوط والأنماط -->
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    
    <!-- تم نقل استدعاء سكربت خرائط جوجل إلى داخل الكود ليتم تحميله ديناميكياً -->

    <!-- قسم الأنماط المخصصة (Custom CSS) -->
    <style>
        html, body { height: 100%; }
        body { font-family: 'Cairo', sans-serif; overscroll-behavior: none; -webkit-tap-highlight-color: transparent; overflow: hidden; }
        
        .dark-mode { background-color: #020617; color: #e2e8f0; }
        .dark-mode body { background-color: #020617; }

        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); animation: fade-in 0.3s ease-out forwards; }
        .modal-content { background-color: white; padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); width: 95%; max-width: 800px; max-height: 90vh; overflow-y: auto; animation: slide-in-down 0.3s ease-out forwards; transform-origin: center; }
        .dark-mode .modal-content { background-color: #1e293b; }
        
        .button-primary { background-color: #2563eb; color: white; padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); }
        .button-primary:hover { background-color: #1d4ed8; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); transform: translateY(-1px); }
        .button-secondary { background-color: #64748b; color: white; padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s; }
        .button-secondary:hover { background-color: #475569; transform: translateY(-1px); }
        .button-tertiary { background-color: #1e293b; color: white; padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s; }
        .button-tertiary:hover { background-color: #334155; transform: translateY(-1px); }

        .icon-button { background: transparent; border: none; cursor: pointer; padding: 0.75rem; width: 48px; height: 48px; border-radius: 9999px; transition: background-color 0.2s, transform 0.2s; line-height: 1; display: flex; align-items: center; justify-content: center; }
        .icon-button:hover { background-color: rgba(0,0,0,0.1); transform: scale(1.1); }
        .dark-mode .icon-button:hover { background-color: rgba(255,255,255,0.1); }
        .icon-button.active { background-color: #2563eb; color: white; }
        .icon-button.danger.active { background-color: #ef4444; color: white; }
        .icon-button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; background-color: transparent !important; }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        .dark-mode ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #a8a29e; border-radius: 4px; }
        .dark-mode ::-webkit-scrollbar-thumb { background: #475569; }
        
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slide-in-down { from { opacity: 0; transform: translateY(-20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }
        @keyframes slide-in-up { from { transform: translateY(100%); } to { transform: translateY(0); } }
        @keyframes slide-out-down { from { transform: translateY(0); } to { transform: translateY(100%); } }

        .toast-container { position: fixed; top: 1rem; left: 1rem; right: 1rem; z-index: 1001; display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
        .toast { background-color: white; color: #333; padding: 0.75rem 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: space-between; width: 100%; max-width: 400px; animation: slide-in-down 0.3s ease-out forwards, fade-out 0.5s ease-in 2.5s forwards; }
        .dark-mode .toast { background-color: #1e293b; color: #e2e8f0; }
        .toast.success { border-right: 4px solid #10b981; }
        .toast.error { border-right: 4px solid #ef4444; }
        .toast.info { border-right: 4px solid #3b82f6; }
        .toast-close-button { background: none; border: none; color: #666; cursor: pointer; font-size: 1.2rem; margin-right: -0.5rem; }
        .dark-mode .toast-close-button { color: #ccc; }

        @keyframes slide-in-right { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes fade-out { from { opacity: 1; } to { opacity: 0; } }
        
        .color-picker-label { position: relative; display: inline-block; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; border: 2px solid white; box-shadow: 0 0 0 1px rgba(0,0,0,0.2); transition: transform 0.2s; }
        .color-picker-label:hover { transform: scale(1.2); }
        .color-picker-label input[type="color"] { position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
        
        .custom-select { -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); background-position: left 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em; padding-left: 2.5rem; }
        .dark-mode .custom-select { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); }
    
        /* --- أنماط جديدة لتسميات الخريطة --- */
        .point-label-card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border-radius: 8px;
            padding: 4px 8px;
            font-family: 'Cairo', sans-serif;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            position: relative;
            white-space: nowrap;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .dark-mode .point-label-card {
            background: rgba(30, 41, 59, 0.9);
            border-color: #334155;
            color: #e2e8f0;
        }
        .point-label-card::after {
            content: '';
            position: absolute;
            bottom: -7px;
            left: 50%;
            transform: translateX(-50%);
            width: 1.5px;
            height: 7px;
            background-color: #475569;
        }
        .dark-mode .point-label-card::after {
            background-color: #94a3b8;
        }
        .point-label-main {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .point-label-header {
            font-weight: 700;
            font-size: 12px;
            color: #1e293b;
        }
        .dark-mode .point-label-header {
            color: #f1f5f9;
        }
        .point-label-body {
            font-weight: 600;
            font-size: 11px;
            color: #475569;
        }
        .dark-mode .point-label-body {
            color: #94a3b8;
        }
        .point-label-separator {
            color: #cbd5e1;
        }
        .dark-mode .point-label-separator {
            color: #475569;
        }
        .point-label-desc {
            font-size: 10px;
            color: #64748b;
            border-top: 1px solid #e2e8f0;
            margin-top: 3px;
            padding-top: 3px;
            width: 100%;
            text-align: center;
        }
        .dark-mode .point-label-desc {
            color: #9ca3af;
            border-color: #334155;
        }

        .distance-label {
            font-size: 14px;
            font-weight: 700;
            color: white;
            text-shadow: 0 0 4px black, 0 0 4px black, 0 0 4px black;
            padding: 2px 4px;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .area-label-card {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 8px;
            padding: 10px 12px;
            text-align: right;
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: none;
            min-width: 200px;
        }
        .dark-mode .area-label-card {
            background: rgba(15, 23, 42, 0.85);
            border-color: #334155;
        }
        .area-label-card div {
            font-size: 14px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .dark-mode .area-label-card div {
            color: #cbd5e1;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // ====================================================================
        //  BLOCK: IMPORTS & SETUP
        // ====================================================================
        const { useState, useEffect, useRef, useCallback, useMemo, createContext, useContext, forwardRef, useImperativeHandle } = React;
        const { createRoot } = ReactDOM;
        // Note: jsPDF is accessed via window.jspdf to ensure it's loaded.

        // ====================================================================
        //  FILE: src/constants.js
        // ====================================================================
        const GOOGLE_MAPS_API_KEY = 'AIzaSyAKXVuJsf0vANjBtlUIWcPj-wNWPkOc-S4';
        const DEFAULT_UTM_ZONE = 35; 
        const DEFAULT_MAP_CENTER_LAT = 30.04439461; 
        const DEFAULT_MAP_CENTER_LNG = 31.23577427; 
        const DEFAULT_MAP_ZOOM = 18;
        const SNAP_TOLERANCE_METERS = 10;
        const MAX_ZOOM_FOR_SNAP = 21;
        const LABEL_VISIBILITY_ZOOM_THRESHOLD = 17;
        const MARKER_VISIBILITY_ZOOM_THRESHOLD = 15;
        const DISTANCE_LABEL_VISIBILITY_ZOOM_THRESHOLD = 16;
        const AREA_LABEL_VISIBILITY_ZOOM_THRESHOLD = 14;
        const POINT_GROUP_COLORS = ['#3b82f6', '#22c55e', '#f97316', '#8b5cf6', '#ef4444', '#ec4899', '#14b8a6', '#6b7280'];
        
        const DEFAULT_GROUP_SETTINGS = {
            showPolylines: true,
            showElevations: false,
            showLabels: false,
            showDescriptions: false,
            isMeasuring: false,
            isAreaMeasuring: false,
            snapEnabled: false,
            isVisible: true,
        };
        
        const MARKER_ICONS = {
            default: { type: 'default', label: 'دائرة', path: 'M 0, 0 m -10, 0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0', scale: 0.8, strokeWeight: 2.5 },
            square: { type: 'custom', label: 'مربع', path: 'M -8 -8 L 8 -8 L 8 8 L -8 8 Z', anchor: { x: 0, y: 0 }, scale: 1.2, strokeWeight: 2.5 },
            triangle: { type: 'custom', label: 'مثلث', path: 'M 0 -10 L 11.5 8 L -11.5 8 Z', anchor: { x: 0, y: 0 }, scale: 1.1, strokeWeight: 2.5 },
            cross: { type: 'custom', label: 'تقاطع (+)', path: 'M -10,0 L 10,0 M 0,-10 L 0,10', scale: 1.2, strokeWeight: 3 },
            x_cross: { type: 'custom', label: 'اكس (X)', path: 'M -9,-9 L 9,9 M 9,-9 L -9,9', scale: 1.2, strokeWeight: 3 },
            benchmark: { type: 'custom', label: 'روبير', path: 'M 0 -12 L 12 6 L -12 6 Z M -12 6 L 12 6', anchor: { x: 0, y: 0 }, scale: 1, strokeWeight: 2.5 },
            station: { type: 'custom', label: 'نقطة محطة', path: 'M 0,0 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0 M 0,-12 L 0,12 M -12,0 L 12,0', anchor: { x: 0, y: 0 }, scale: 1, strokeWeight: 2 },
            control_point: { type: 'custom', label: 'نقطة تحكم', path: 'M -10 -10 L 10 -10 L 10 10 L -10 10 Z M 0,0 m -3,0 a 3,3 0 1,0 6,0 a 3,3 0 1,0 -6,0', anchor: { x: 0, y: 0 }, scale: 1.1, strokeWeight: 2.5 },
            manhole: { type: 'custom', label: 'مانهول', path: 'M 0,0 m -12,0 a 12,12 0 1,0 24,0 a 12,12 0 1,0 -24,0 M 0,0 m -8,0 a 8,8 0 1,0 16,0 a 8,8 0 1,0 -16,0', anchor: { x: 0, y: 0 }, scale: 0.9, strokeWeight: 2 },
            valve: { type: 'custom', label: 'صمام', path: 'M -8,-8 L 8,8 M 8,-8 L -8,8', anchor: { x: 0, y: 0 }, scale: 1.2, strokeWeight: 4 },
            hydrant: { type: 'custom', label: 'حنفية حريق', path: 'M 0,0 m -8,0 a 8,8 0 1,0 16,0 a 8,8 0 1,0 -16,0 M -12, -4 L -12, 4 L -8,0 z M 12,-4 L 12,4 L 8,0 z', anchor: { x: 0, y: 0 }, scale: 1, strokeWeight: 2.5 },
            pole: { type: 'custom', label: 'عمود', path: 'M 0, 0 m -8, 0 a 8,8 0 1,0 16,0 a 8,8 0 1,0 -16,0 M 0,0 l 0, -12', anchor: { x: 0, y: 0 }, scale: 1, strokeWeight: 2 },
            tree: { type: 'custom', label: 'شجرة', path: 'M 0 -5 Q 5 -15 10 -5 T 0 5 Q -5 -5 -10 -5 T 0 -5 Z M 0 5 L 0 15', anchor: { x: 0, y: 15 }, scale: 1, strokeWeight: 2 },
        };
        
        // ====================================================================
        //  FILE: src/utils.js
        // ====================================================================
        const generateUniqueId = () => Math.random().toString(36).substring(2, 9);
        
        if (window.proj4) {
            proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
            for (let i = 30; i <= 40; i++) {
                proj4.defs(`EPSG:326${i}`, `+proj=utm +zone=${i} +datum=WGS84 +units=m +no_defs`);
            }
        }

        const convertLatLngToUtm = (lat, lng, zone) => {
            try {
                const utmProjection = `EPSG:326${zone}`;
                if (!window.proj4.defs[utmProjection]) return null;
                const [easting, northing] = window.proj4("EPSG:4326", utmProjection, [lng, lat]);
                return { easting, northing, zone, hemisphere: lat >= 0 ? 'N' : 'S' };
            } catch (error) { console.error("Conversion error:", error); return null; }
        };

        const convertUtmToLatLng = (easting, northing, zone) => {
            try {
                const utmProjection = `EPSG:326${zone}`;
                if (!window.proj4.defs[utmProjection]) return null;
                const [lng, lat] = window.proj4(utmProjection, "EPSG:4326", [easting, northing]);
                return { lat, lng };
            } catch (error) { console.error("Conversion error:", error); return null; }
        };
        
        const getElevation = async (latLng, retries = 3, delay = 1000) => {
            if (!window.google || !window.google.maps || !window.google.maps.ElevationService) {
                console.warn("Google Maps Elevation Service not available.");
                return { elevation: null, status: 'NO_SERVICE' };
            }
            const elevationService = new window.google.maps.ElevationService();
            let lastStatus = '';

            for (let i = 0; i < retries; i++) {
                const result = await new Promise(resolve => {
                    elevationService.getElevationForLocations({ 'locations': [new window.google.maps.LatLng(latLng.lat, latLng.lng)] }, (results, status) => {
                        lastStatus = status;
                        if (status === 'OK' && results && results[0]) {
                            resolve({ success: true, elevation: results[0].elevation });
                        } else {
                            console.warn(`Elevation service attempt ${i + 1} failed with status: ${status}`);
                            resolve({ success: false });
                        }
                    });
                });
                if (result.success) return { elevation: result.elevation, status: 'OK' };
                if (lastStatus !== 'UNKNOWN_ERROR' && lastStatus !== 'OVER_QUERY_LIMIT') {
                    break; 
                }
                if (i < retries - 1) await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
            }
            console.warn(`Elevation service failed after all retries with final status: ${lastStatus}`);
            return { elevation: null, status: lastStatus };
        };

        const getCurrentLocation = () => {
            return new Promise(resolve => {
                if (!navigator.geolocation) {
                    resolve({ location: null, error: { message: "المتصفح لا يدعم تحديد الموقع." } });
                    return;
                }
                navigator.geolocation.getCurrentPosition(
                    pos => resolve({ location: { lat: pos.coords.latitude, lng: pos.coords.longitude }, error: null }),
                    err => {
                        let message = 'تعذر جلب الموقع الحالي.';
                        if (err.code === err.PERMISSION_DENIED) {
                            message = err.message.includes('policy') ? 'تم تعطيل تحديد الموقع بواسطة سياسة الأمان.' : 'تم رفض إذن تحديد الموقع.';
                        }
                        resolve({ location: null, error: { message } });
                    },
                    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                );
            });
        };

        const parseDelimitedText = (text) => {
            if (!text || typeof text !== 'string') return { data: [], error: "المحتوى فارغ أو غير صالح." };
            const lines = text.trim().split(/\r?\n/).filter(line => line.trim() !== '');
            if (lines.length === 0) return { data: [], error: "الملف فارغ." };
            
            const delimiters = [',', '\t', ';', ' '];
            let bestDelimiter = ',';
            let maxCols = 0;
            for (const d of delimiters) {
                const cols = lines[0].split(d).length;
                if (cols > maxCols) {
                    maxCols = cols;
                    bestDelimiter = d;
                }
            }

            const data = lines.map(line => line.split(bestDelimiter).map(cell => cell.trim()));
            
            if (data.some(row => row.length !== data[0].length)) {
                 return { data, error: "بعض الصفوف لا تتطابق مع عدد الأعمدة." };
            }
            
            let hasHeader = false;
            const firstRow = data[0];
            if (firstRow) {
                const isNumericRow = firstRow.every(cell => cell.trim() === '' || (!isNaN(parseFloat(cell)) && isFinite(cell)));
                if (!isNumericRow) {
                    hasHeader = true;
                }
            }

            return { data, error: null, hasHeader };
        };

        const downloadFile = (content, fileName, mimeType) => {
            const blob = new Blob([content], { type: mimeType });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };

        // ====================================================================
        //  FILE: src/hooks/useHistoryState.js
        // ====================================================================
        const useHistoryState = (initialState) => {
            const historyRef = useRef({ past: [], present: initialState, future: [] });
            const [, forceUpdate] = useState({});

            const setState = useCallback((action) => {
                const { past, present } = historyRef.current;
                const newPresent = typeof action === 'function' ? action(present) : action;
                
                if (JSON.stringify(present) === JSON.stringify(newPresent)) return;

                historyRef.current = {
                    past: [...past, present],
                    present: newPresent,
                    future: []
                };
                forceUpdate({});
            }, []);

            const undo = useCallback(() => {
                const { past, present, future } = historyRef.current;
                if (past.length === 0) return;
                const previous = past[past.length - 1];
                const newPast = past.slice(0, past.length - 1);
                historyRef.current = {
                    past: newPast,
                    present: previous,
                    future: [present, ...future]
                };
                forceUpdate({});
            }, []);

            const redo = useCallback(() => {
                const { past, present, future } = historyRef.current;
                if (future.length === 0) return;
                const next = future[0];
                const newFuture = future.slice(1);
                historyRef.current = {
                    past: [...past, present],
                    present: next,
                    future: newFuture
                };
                forceUpdate({});
            }, []);

            return [
                historyRef.current.present,
                setState,
                undo,
                redo,
                historyRef.current.past.length > 0,
                historyRef.current.future.length > 0
            ];
        };


        // ====================================================================
        //  FILE: src/contexts/AppContext.js
        // ====================================================================
        const AppContext = createContext();
        const AppProvider = ({ children }) => {
            const [darkMode, setDarkMode] = useState(false);
            const [utmZone, setUtmZone] = useState(DEFAULT_UTM_ZONE);
            const [toasts, setToasts] = useState([]);
            const [coordinateSystem, setCoordinateSystem] = useState('utm');
            
            useEffect(() => { document.documentElement.classList.toggle('dark-mode', darkMode); }, [darkMode]);

            const addToast = useCallback((message, type = 'info', duration = 3000) => {
                const id = generateUniqueId();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), duration);
            }, []);
            
            const value = useMemo(() => ({
                darkMode, setDarkMode, utmZone, setUtmZone, addToast, coordinateSystem, setCoordinateSystem
            }), [darkMode, utmZone, addToast, coordinateSystem]);

            return (
                <AppContext.Provider value={value}>
                    {children}
                    <div className="toast-container">
                        {toasts.map(toast => <Toast key={toast.id} {...toast} onDismiss={() => setToasts(p => p.filter(t => t.id !== toast.id))} />)}
                    </div>
                </AppContext.Provider>
            );
        };
        const useAppContext = () => useContext(AppContext);

        // ====================================================================
        //  FILE: src/components/common/Toast.js, Icon.js
        // ====================================================================
        const Toast = ({ id, message, type, onDismiss }) => (
            <div className={`toast ${type}`}>
                <div className="flex items-center"><Icon name={type === 'success' ? 'check-circle' : 'x-circle'} className="ml-2" size={20} /><span>{message}</span></div>
                <button onClick={() => onDismiss(id)} className="toast-close-button"><Icon name="x" size={16} /></button>
            </div>
        );
        
        const Icon = ({ name, ...props }) => {
            useEffect(() => { window.lucide?.createIcons(); }, [name, props]);
            return <i data-lucide={name} {...props}></i>;
        };

        // ====================================================================
        //  FILE: src/components/layout/Header.js, Sidebar.js
        // ====================================================================
        const Header = ({ onToggleFullScreen, isFullScreen, onToggleSidebar }) => {
            const { darkMode, setDarkMode } = useAppContext();
            return (
                <header className="flex-shrink-0 bg-white shadow-md z-30 p-2 dark:bg-slate-800 dark:border-b dark:border-slate-700">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-4 space-x-reverse">
                            <button onClick={onToggleSidebar} className="icon-button lg:hidden"><Icon name="menu" /></button>
                            <Icon name="map-pin" className="text-blue-600" size={32} />
                            <div>
                                <h1 className="text-md sm:text-lg font-bold">تطبيق الخرائط الهندسية</h1>
                                <p className="text-xs text-slate-500 dark:text-slate-400">تطوير: م. حمدي وحيد</p>
                            </div>
                        </div>
                        <div className="flex items-center space-x-1 sm:space-x-2 space-x-reverse">
                            <button onClick={() => setDarkMode(d => !d)} className="icon-button" title="الوضع الداكن/الفاتح"><Icon name={darkMode ? 'sun' : 'moon'} /></button>
                            <button onClick={onToggleFullScreen} className="icon-button hidden sm:flex" title="ملء الشاشة"><Icon name={isFullScreen ? 'minimize' : 'maximize'} /></button>
                        </div>
                    </div>
                </header>
            );
        };
        
        const Sidebar = ({ isOpen, onClose, workAreas, selectedAreaId, selectedGroupId, onSelectArea, onSelectGroup, onAddNewArea, onRenameArea, onDeleteArea, onZoomToWorkArea, onAddNewGroup, onRenameGroup, onDeleteGroup, onZoomToGroup, onUpdateGroupColor, onOpenExportModal, onToggleGroupVisibility, onSetGroupMarker, onOpenImportModal, onOpenPdfOptions, setModal, closeModal }) => {
            const { utmZone, setUtmZone, coordinateSystem, setCoordinateSystem } = useAppContext();
            const selectedArea = workAreas.find(area => area.id === selectedAreaId);
            const selectedGroup = selectedArea?.groups.find(group => group.id === selectedGroupId);

            const promptAction = (title, message, inputLabel, initialValue, onConfirm) => {
                setModal({ type: 'prompt', props: { title, message, inputLabel, initialValue, onConfirm, onClose: closeModal } });
            };
            const confirmAction = (title, message, onConfirm) => {
                setModal({ type: 'confirm', props: { title, message, onConfirm, onClose: closeModal } });
            };

            const openGroupMarkerPicker = () => {
                if (!selectedArea || !selectedGroup) return;
                setModal({
                    type: 'markerPicker',
                    props: {
                        onClose: closeModal,
                        onSelect: (iconKey) => {
                            onSetGroupMarker(selectedArea.id, selectedGroup.id, iconKey);
                            closeModal();
                        },
                        currentIconKey: selectedGroup.points[0]?.markerIcon || 'default',
                        previewColor: selectedGroup.color,
                    }
                });
            };

            const sidebarClasses = `
                fixed inset-y-0 right-0 z-40 w-72 bg-white p-4 overflow-y-auto flex-shrink-0 shadow-lg dark:bg-slate-800
                transition-transform duration-300 ease-in-out
                ${isOpen ? 'translate-x-0' : 'translate-x-full'}
                lg:relative lg:translate-x-0 lg:w-72
            `;

            return (
                <>
                    <div className={`fixed inset-0 bg-gray-900/50 z-30 lg:hidden ${isOpen ? 'block' : 'hidden'}`} onClick={onClose}></div>
                    <aside className={sidebarClasses}>
                        {/* قسم مناطق العمل */}
                        <div className="mb-6">
                            <div className="flex justify-between items-center mb-2 p-2 bg-slate-50 dark:bg-slate-900/50 rounded-lg border-b border-slate-200 dark:border-slate-700">
                                <h2 className="text-lg font-bold flex items-center gap-2">
                                    <Icon name="folder-kanban" size={20} className="text-slate-500"/>
                                    <span>مناطق العمل</span>
                                </h2>
                                <button onClick={onAddNewArea} className="icon-button !w-10 !h-10" title="إضافة منطقة عمل"><Icon name="plus-circle" className="text-blue-500" /></button>
                            </div>
                            <select id="work-area-select" value={selectedAreaId || ''} onChange={e => onSelectArea(e.target.value)} className="w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 mb-2 text-base custom-select">
                                {workAreas.map(area => (
                                    <option key={area.id} value={area.id}>{area.name} ({area.groups.length})</option>
                                ))}
                            </select>
                            {selectedArea && (
                                <div className="flex justify-between items-center mt-1">
                                    <span className="text-xs text-slate-500 dark:text-slate-400">{selectedArea.groups.length} مجموعات</span>
                                    <div className="flex items-center space-x-0 space-x-reverse">
                                        <button onClick={() => promptAction("تعديل الاسم", "أدخل الاسم الجديد:", "الاسم", selectedArea.name, newName => newName && onRenameArea(selectedArea.id, newName.trim()))} className="icon-button" title="تعديل"><Icon name="file-pen-line" size={18}/></button>
                                        <button onClick={() => confirmAction("تأكيد الحذف", `هل تريد حذف "${selectedArea.name}"؟`, () => onDeleteArea(selectedArea.id))} className="icon-button text-red-500" title="حذف"><Icon name="trash-2" size={18}/></button>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* قسم مجموعات النقاط */}
                        {selectedArea && (
                            <div className="border-t pt-4 mt-4 dark:border-slate-700">
                                <div className="flex justify-between items-center mb-2 p-2 bg-slate-50 dark:bg-slate-900/50 rounded-lg border-b border-slate-200 dark:border-slate-700">
                                    <h2 className="text-lg font-bold flex items-center gap-2">
                                        <Icon name="folder-pen" size={20} className="text-slate-500"/>
                                        <span>المجموعة النشطة</span>
                                    </h2>
                                    <button onClick={() => onAddNewGroup(selectedArea.id)} className="icon-button !w-10 !h-10" title="إضافة مجموعة"><Icon name="folder-plus" className="text-blue-500" /></button>
                                </div>
                                <select id="point-group-select" value={selectedGroupId || ''} onChange={e => {
                                    const groupId = e.target.value;
                                    onSelectGroup(groupId);
                                    onZoomToGroup(selectedArea.id, groupId);
                                }} className="w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 mb-2 text-base custom-select">
                                    {selectedArea.groups.map(group => (
                                        <option key={group.id} value={group.id}>{group.name} ({group.points.length})</option>
                                    ))}
                                </select>
                                {selectedGroup && (
                                    <div className="flex justify-between items-center mt-1">
                                        <div className="flex items-center space-x-2 space-x-reverse">
                                            <label className="color-picker-label" style={{ backgroundColor: selectedGroup.color }}>
                                                <input type="color" value={selectedGroup.color} onChange={(e) => onUpdateGroupColor(selectedArea.id, selectedGroup.id, e.target.value)} onClick={e => e.stopPropagation()} />
                                            </label>
                                            <span className="text-xs text-slate-500 dark:text-slate-400">{selectedGroup.points.length} نقاط</span>
                                        </div>
                                        <div className="flex items-center space-x-0 space-x-reverse">
                                            <button 
                                                onClick={() => onToggleGroupVisibility(selectedArea.id, selectedGroup.id)} 
                                                className={`icon-button flex-shrink-0 ${selectedGroup.isVisible ? 'active' : ''}`} 
                                                title={selectedGroup.isVisible ? 'إخفاء المجموعة' : 'إظهار المجموعة'}
                                            >
                                                <Icon name={selectedGroup.isVisible ? 'eye' : 'eye-off'} size={18} />
                                            </button>
                                            <button onClick={openGroupMarkerPicker} className="icon-button" title="تغيير رمز كل النقاط في المجموعة">
                                                <Icon name="shapes" size={18}/>
                                            </button>
                                            <button onClick={() => promptAction("تعديل اسم المجموعة", "أدخل الاسم الجديد:", "الاسم", selectedGroup.name, newName => newName && onRenameGroup(selectedArea.id, selectedGroup.id, newName.trim()))} className="icon-button" title="تعديل"><Icon name="file-pen-line" size={18}/></button>
                                            <button onClick={() => confirmAction("تأكيد حذف المجموعة", `هل تريد حذف "${selectedGroup.name}"؟`, () => onDeleteGroup(selectedArea.id, selectedGroup.id))} className="icon-button text-red-500" title="حذف"><Icon name="trash-2" size={18}/></button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                        
                        <div className="border-t pt-4 mt-4 dark:border-slate-700">
                            <h3 className="font-semibold mb-2">الإعدادات وإدارة البيانات</h3>
                            <div className="mb-4">
                                <label className="block text-sm font-medium mb-1">نظام الإحداثيات</label>
                                <div className="flex rounded-md shadow-sm">
                                    <button onClick={() => setCoordinateSystem('utm')} className={`flex-1 p-2 rounded-r-md border border-slate-300 dark:border-slate-600 ${coordinateSystem === 'utm' ? 'bg-blue-600 text-white' : 'bg-white dark:bg-slate-700'}`}>UTM</button>
                                    <button onClick={() => setCoordinateSystem('latlng')} className={`flex-1 p-2 rounded-l-md border border-slate-300 dark:border-slate-600 ${coordinateSystem === 'latlng' ? 'bg-blue-600 text-white' : 'bg-white dark:bg-slate-700'}`}>Lat/Long</button>
                                </div>
                            </div>
                            <label htmlFor="utm-zone-select" className="block text-sm font-medium mb-1">UTM Zone</label>
                            <select id="utm-zone-select" value={utmZone} onChange={e => setUtmZone(parseInt(e.target.value))} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 custom-select" disabled={coordinateSystem === 'latlng'}>
                                {Array.from({ length: 11 }, (_, i) => 30 + i).map(zone => <option key={zone} value={zone}>{zone}N</option>)}
                            </select>
                            <div className="mt-4 flex flex-col space-y-2">
                                <button onClick={onOpenImportModal} className="button-secondary flex items-center justify-center text-sm"><Icon name="upload" className="ml-2" size={18} />استيراد / تحميل</button>
                                <button onClick={onOpenExportModal} className="button-primary flex items-center justify-center text-sm"><Icon name="download" className="ml-2" size={18} />تصدير / حفظ</button>
                                <button onClick={onOpenPdfOptions} className="button-tertiary flex items-center justify-center text-sm"><Icon name="file-text" className="ml-2" size={18} />تقرير PDF</button>
                            </div>
                        </div>
                    </aside>
                </>
            );
        };
        
        const GenericModal = ({ type, title, message, inputLabel, initialValue, onConfirm, onClose, onCancel, children, confirmText = "تأكيد", showConfirm = true, showCancel = true, cancelText = "إلغاء" }) => {
            const [inputValue, setInputValue] = useState(initialValue || '');
            const inputRef = useRef(null);
            useEffect(() => { 
                if (type === 'prompt' && inputRef.current) {
                    inputRef.current.focus();
                    inputRef.current.select();
                } 
            }, [type]);
            const handleConfirm = () => { onConfirm(type === 'prompt' ? inputValue : undefined); onClose(); };
            const handleCancel = () => { if(onCancel) onCancel(); onClose(); };
            return (
                <div className="modal-overlay" onClick={handleCancel}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-slate-100">{title}</h2>
                        {message && <p className="mb-6 text-gray-800 dark:text-slate-300">{message}</p>}
                        {type === 'prompt' && (
                            <div className="mb-6">
                                <label htmlFor="modal-input" className="block text-sm font-medium mb-1 text-gray-700 dark:text-slate-200">{inputLabel}</label>
                                <input id="modal-input" ref={inputRef} type="text" value={inputValue} onChange={e => setInputValue(e.target.value)} onKeyDown={e => e.key === 'Enter' && handleConfirm()} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600" />
                            </div>
                        )}
                        {children}
                        <div className="flex justify-end space-x-3 space-x-reverse mt-6">
                            {showCancel && <button onClick={handleCancel} className="button-secondary">{cancelText}</button>}
                            {showConfirm && <button onClick={handleConfirm} className="button-primary">{confirmText}</button>}
                        </div>
                    </div>
                </div>
            );
        };

        // ====================================================================
        //  FILE: src/components/table/PointsTable.js
        // ====================================================================
        const PointsTable = ({ selectedArea, selectedGroupId, onUpdatePoint, onDeletePoint, onZoomToPoint, onActivateGroup, activePointId, setActivePointId, onOpenMarkerPicker, setModal, closeModal }) => {
            const { addToast, coordinateSystem } = useAppContext();
            const rowRefs = useRef({});
            const groupHeaderRefs = useRef({});
        
            useEffect(() => {
                if (activePointId && rowRefs.current[activePointId]) {
                    rowRefs.current[activePointId].scrollIntoView({
                        behavior: 'smooth',
                        block: 'center',
                    });
                }
            }, [activePointId]);

            useEffect(() => {
                if (selectedGroupId && groupHeaderRefs.current[selectedGroupId]) {
                    groupHeaderRefs.current[selectedGroupId].scrollIntoView({
                        behavior: 'smooth',
                        block: 'start',
                    });
                }
            }, [selectedGroupId]);

            const handleOpenMarkerPicker = (e, point, group) => {
                e.stopPropagation();
                setModal({type: 'markerPicker', props: {
                    onClose: closeModal,
                    onSelect: (iconKey) => {
                        onUpdatePoint(selectedArea.id, group.id, point.id, 'markerIcon', iconKey);
                        closeModal();
                    },
                    currentIconKey: point.markerIcon || 'default',
                    previewColor: group.color
                }});
            };

            const copyToClipboard = (text, message) => {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.top = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    addToast(message, 'success');
                } catch (err) {
                    addToast('فشل النسخ إلى الحافظة.', 'error');
                }
                document.body.removeChild(textArea);
            };

            const copyUtmToClipboard = (point) => {
                if (!point) return;
                const safeToFixed = (num, digits = 3) => (typeof num === 'number' ? num.toFixed(digits) : '0.000');
                const textToCopy = `${safeToFixed(point.utm?.easting)},${safeToFixed(point.utm?.northing)},${safeToFixed(point.elevation)}`;
                copyToClipboard(textToCopy, 'تم نسخ إحداثيات UTM.');
            };
            
            const copyLatLngToClipboard = (point) => {
                const textToCopy = `${point.lat.toFixed(8)},${point.lng.toFixed(8)}`;
                copyToClipboard(textToCopy, 'تم نسخ إحداثيات Lat/Lng.');
            };

            if (!selectedArea) return <div className="p-4 text-center text-slate-500 h-full flex items-center justify-center">الرجاء تحديد منطقة عمل.</div>;
            
            const coordInputClasses = "w-full p-1 border rounded bg-slate-50 text-slate-800 font-mono dark:bg-slate-700 dark:text-slate-200 dark:border-slate-600 focus:ring-2 focus:ring-blue-500 transition-colors";

            const PointCard = ({ point, group, index }) => (
                <div 
                    key={point.id}
                    ref={el => (rowRefs.current[point.id] = el)}
                    onClick={() => {
                        onZoomToPoint(selectedArea.id, group.id, point.id);
                        onActivateGroup(group.id);
                        setActivePointId(point.id);
                    }}
                    className={`p-3 border-b dark:border-slate-700 hover:bg-slate-100 dark:hover:bg-slate-800 cursor-pointer transition-colors duration-200 ${point.id === activePointId ? 'bg-blue-100 dark:bg-blue-900/50 ring-2 ring-blue-500 z-10' : ''}`}
                >
                    <div className="flex items-center gap-3">
                        <div className="flex-grow">
                            <div className="flex justify-between items-center mb-2">
                                <div className="flex items-center gap-2">
                                    <span className="font-bold text-slate-700 dark:text-slate-200">{`نقطة ${index + 1}`}</span>
                                    <span className="text-xs px-2 py-0.5 rounded-full" style={{backgroundColor: group.color, color: 'white'}}>{group.name}</span>
                                </div>
                                <div className="flex items-center space-x-0 space-x-reverse">
                                    <button onClick={(e) => { e.stopPropagation(); onOpenMarkerPicker(point, group); }} className="icon-button text-indigo-500 !w-11 !h-11" title="تغيير الرمز"><Icon name="palette" size={22}/></button>
                                    <button onClick={(e) => { e.stopPropagation(); onDeletePoint(group.id, point.id);}} className="icon-button text-red-500 !w-11 !h-11" title="حذف"><Icon name="trash-2" size={22}/></button>
                                </div>
                            </div>
                            <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-sm font-mono">
                                {coordinateSystem === 'utm' ? (
                                    <>
                                        <div className="text-slate-500 dark:text-slate-400">X: <span className="text-slate-800 dark:text-slate-100">{point.utm?.easting?.toFixed(2) || 'N/A'}</span></div>
                                        <div className="text-slate-500 dark:text-slate-400">Y: <span className="text-slate-800 dark:text-slate-100">{point.utm?.northing?.toFixed(2) || 'N/A'}</span></div>
                                    </>
                                ) : (
                                    <>
                                        <div className="text-slate-500 dark:text-slate-400">Lat: <span className="text-slate-800 dark:text-slate-100">{point.lat?.toFixed(6) || 'N/A'}</span></div>
                                        <div className="text-slate-500 dark:text-slate-400">Lng: <span className="text-slate-800 dark:text-slate-100">{point.lng?.toFixed(6) || 'N/A'}</span></div>
                                    </>
                                )}
                                <div className="text-slate-500 dark:text-slate-400">Z: <span className="text-slate-800 dark:text-slate-100">{point.elevation?.toFixed(2) || 'N/A'}</span></div>
                            </div>
                            {point.description && <p className="text-xs text-slate-600 dark:text-slate-400 mt-2">{point.description}</p>}
                        </div>
                    </div>
                </div>
            );

            return (
                <div className="flex-grow overflow-auto h-full bg-white dark:bg-slate-800 flex flex-col">
                    <div className="flex-shrink-0 p-2 flex justify-between items-center border-b dark:border-slate-700">
                        <h3 className="font-bold text-md text-slate-800 dark:text-slate-100">نقاط: {selectedArea.name}</h3>
                    </div>
                    <div className="flex-grow overflow-y-auto">
                        <div className="lg:hidden">
                            {selectedArea.groups.map(group => (
                                <div key={group.id} className="mb-2" ref={el => (groupHeaderRefs.current[group.id] = el)}>
                                    {(group.points || []).map((point, i) => (
                                        <PointCard key={point.id} point={point} group={group} index={i} />
                                    ))}
                                </div>
                            ))}
                        </div>

                        <div className="hidden lg:block">
                             {selectedArea.groups.map(group => (
                                <div key={group.id} className="mb-4" ref={el => (groupHeaderRefs.current[group.id] = el)}>
                                    <div className="flex items-center mb-2 p-2 rounded-lg bg-slate-100 dark:bg-slate-800 sticky top-0 z-10">
                                        <h4 className="font-semibold text-slate-700 dark:text-slate-200">{group.name}</h4>
                                    </div>
                                    <div className="overflow-x-auto">
                                        <table className="w-full text-sm text-left">
                                            <thead className="text-xs text-gray-700 uppercase bg-slate-200 dark:bg-slate-700 dark:text-gray-400"><tr>
                                                <th className="px-2 py-2 text-center">Actions</th>
                                                <th className="px-4 py-2">Description</th>
                                                <th className="px-4 py-2">Elevation (Z)</th>
                                                {coordinateSystem === 'utm' ? (
                                                    <>
                                                        <th className="px-4 py-2">Northing (Y)</th>
                                                        <th className="px-4 py-2">Easting (X)</th>
                                                    </>
                                                ) : (
                                                    <>
                                                        <th className="px-4 py-2">Longitude</th>
                                                        <th className="px-4 py-2">Latitude</th>
                                                    </>
                                                )}
                                                <th className="px-2 py-2">#</th>
                                            </tr></thead>
                                            <tbody>
                                            {(group.points || []).map((point, i) => (
                                                <tr 
                                                    key={point.id} 
                                                    ref={el => (rowRefs.current[point.id] = el)}
                                                    onClick={() => {
                                                        onZoomToPoint(selectedArea.id, group.id, point.id);
                                                        onActivateGroup(group.id);
                                                        setActivePointId(point.id);
                                                    }} 
                                                    className={`border-b dark:border-slate-700 hover:bg-slate-100 dark:hover:bg-slate-800 cursor-pointer transition-colors duration-200 even:bg-slate-50 dark:even:bg-slate-800/50 ${point.id === activePointId ? 'bg-blue-100 dark:bg-blue-900/50 ring-2 ring-blue-500 z-10' : ''}`}
                                                >
                                                    <td className="px-2 py-2">
                                                        <div className="flex items-center justify-center space-x-1">
                                                            <button onClick={(e) => handleOpenMarkerPicker(e, point, group)} className="icon-button !w-11 !h-11 text-indigo-500 hover:bg-indigo-100 dark:hover:bg-indigo-900/50" title="تغيير الرمز">
                                                                <Icon name="palette" size={22}/>
                                                            </button>
                                                            <button onClick={(e) => { e.stopPropagation(); copyLatLngToClipboard(point); }} className="icon-button !w-11 !h-11 text-sky-500 hover:bg-sky-100 dark:hover:bg-sky-900/50" title="نسخ Lat/Lng">
                                                                <Icon name="globe-2" size={22}/>
                                                            </button>
                                                            <button onClick={(e) => { e.stopPropagation(); copyUtmToClipboard(point); }} className="icon-button !w-11 !h-11 text-green-500 hover:bg-green-100 dark:hover:bg-green-900/50" title="نسخ UTM">
                                                                <Icon name="copy" size={22}/>
                                                            </button>
                                                            <button onClick={e => {e.stopPropagation(); onDeletePoint(group.id, point.id);}} className="icon-button !w-11 !h-11 text-red-500 hover:bg-red-100 dark:hover:bg-red-900/50" title="حذف">
                                                                <Icon name="trash-2" size={22}/>
                                                            </button>
                                                        </div>
                                                    </td>
                                                    <td className="px-4 py-2">
                                                        <input 
                                                            type="text" 
                                                            value={point.description || ''} 
                                                            onChange={(e) => onUpdatePoint(selectedArea.id, group.id, point.id, 'description', e.target.value)}
                                                            onClick={e => e.stopPropagation()}
                                                            className="w-full p-1 border rounded bg-transparent dark:bg-slate-700 dark:border-slate-600 focus:ring-2 focus:ring-blue-500"
                                                            placeholder="وصف..."
                                                        />
                                                    </td>
                                                    <td className="px-4 py-2"><input type="number" value={point.elevation?.toFixed(3) || '0.000'} readOnly className={coordInputClasses} /></td>
                                                    {coordinateSystem === 'utm' ? (
                                                        <>
                                                            <td className="px-4 py-2"><input type="number" value={point.utm?.northing?.toFixed(3) || ''} readOnly className={coordInputClasses} /></td>
                                                            <td className="px-4 py-2"><input type="number" value={point.utm?.easting?.toFixed(3) || ''} readOnly className={coordInputClasses} /></td>
                                                        </>
                                                    ) : (
                                                         <>
                                                            <td className="px-4 py-2"><input type="number" value={point.lng?.toFixed(8) || ''} readOnly className={coordInputClasses} /></td>
                                                            <td className="px-4 py-2"><input type="number" value={point.lat?.toFixed(8) || ''} readOnly className={coordInputClasses} /></td>
                                                        </>
                                                    )}
                                                    <td className="px-2 py-2 font-medium text-slate-500 dark:text-slate-400">{i + 1}</td>
                                                </tr>
                                            ))}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // ====================================================================
        //  FILE: src/components/map/CustomLabel.js
        // ====================================================================
        const CustomLabel = ({ map, position, text, styleProps }) => {
            const overlay = useRef(null);

            useEffect(() => {
                class CustomLabelOverlay extends window.google.maps.OverlayView {
                    constructor(position, text, styleProps) {
                        super();
                        this.position = position;
                        this.text = text;
                        this.styleProps = styleProps;
                        this.div = null;
                    }

                    onAdd() {
                        const div = document.createElement('div');
                        div.style.position = 'absolute';
                        div.style.whiteSpace = 'nowrap';
                        this.div = div;
                        this.updateText();
                        this.updateStyle();
                        this.getPanes().floatPane.appendChild(this.div);
                        window.lucide?.createIcons();
                    }

                    draw() {
                        const proj = this.getProjection();
                        if (!proj || !this.div) return;
                        const point = proj.fromLatLngToDivPixel(this.position);
                        if (point) {
                            this.div.style.left = point.x + 'px';
                            this.div.style.top = point.y + 'px';
                        }
                    }

                    onRemove() {
                        if (this.div) {
                            this.div.parentNode.removeChild(this.div);
                            this.div = null;
                        }
                    }
                    
                    updateText(text) { 
                        if(this.div) {
                            this.div.innerHTML = text || this.text; 
                            window.lucide?.createIcons();
                        }
                    }
                    updatePosition(position) { this.position = position; this.draw(); }
                    updateStyle(styleProps) {
                        if (!this.div) return;
                        const styles = styleProps || this.styleProps;
                        Object.assign(this.div.style, styles);
                    }
                }

                overlay.current = new CustomLabelOverlay(position, text, styleProps);
                overlay.current.setMap(map);
                
                return () => overlay.current?.setMap(null);
            }, [map]);

            useEffect(() => { overlay.current?.updatePosition(position); }, [position]);
            useEffect(() => { overlay.current?.updateText(text); }, [text]);
            useEffect(() => { overlay.current?.updateStyle(styleProps); }, [styleProps]);

            return null;
        };

        // ====================================================================
        //  FILE: src/components/map/MapComponent.js
        // ====================================================================
        const MapComponent = forwardRef(({ selectedArea, utmZone, onAddPoint, onUpdatePoint, addToast, onUpdateGroupSettings, selectedGroupId, isDeleteMode, onDeletePointById, onActivateGroup, setActivePointId, onZoomChange }, ref) => {
            const { darkMode } = useAppContext();
            const mapRef = useRef(null);
            const [map, setMap] = useState(null);
            const [mapOverlays, setMapOverlays] = useState([]);
            const markersRef = useRef({});
            const polylinesRef = useRef({});
            const infoWindowRef = useRef(null);
            const onAddPointRef = useRef(onAddPoint);
            useEffect(() => { onAddPointRef.current = onAddPoint; }, [onAddPoint]);

            useImperativeHandle(ref, () => ({
                zoomToPoint(lat, lng) { map?.setCenter({ lat, lng }); map?.setZoom(21); },
                zoomToBounds(boundsData) {
                    if (map && boundsData && boundsData.length > 0) {
                        const bounds = new window.google.maps.LatLngBounds();
                        boundsData.forEach(p => bounds.extend(new window.google.maps.LatLng(p.lat, p.lng)));
                        map.fitBounds(bounds, 50);
                    }
                },
                resetView() {
                    map?.setCenter({ lat: DEFAULT_MAP_CENTER_LAT, lng: DEFAULT_MAP_CENTER_LNG });
                    map?.setZoom(DEFAULT_MAP_ZOOM);
                }
            }));

            useEffect(() => {
                if (mapRef.current && !map) {
                    const mapInstance = new window.google.maps.Map(mapRef.current, { center: { lat: DEFAULT_MAP_CENTER_LAT, lng: DEFAULT_MAP_CENTER_LNG }, zoom: DEFAULT_MAP_ZOOM, mapTypeId: 'satellite', mapTypeControl: false, streetViewControl: false, fullscreenControl: false, zoomControl: true, clickableIcons: !isDeleteMode });
                    infoWindowRef.current = new window.google.maps.InfoWindow();
                    
                    mapInstance.addListener('click', (e) => {
                        if (isDeleteMode) {
                            addToast('وضع الحذف مفعل. انقر على نقطة لحذفها.', 'info');
                            return;
                        }
                        onAddPointRef.current(e.latLng.lat(), e.latLng.lng());
                    });
                    
                    mapInstance.addListener('zoom_changed', () => {
                        const currentZoom = mapInstance.getZoom();
                        onZoomChange(currentZoom);
                        if (selectedGroupId) {
                            const shouldBeEnabled = currentZoom < MAX_ZOOM_FOR_SNAP;
                            onUpdateGroupSettings(selectedGroupId, 'snapEnabled', shouldBeEnabled);
                        }
                    });
                    
                    setMap(mapInstance);
                }
            }, [mapRef, map, selectedGroupId, onUpdateGroupSettings]);

            useEffect(() => {
                if(map) {
                    map.setOptions({ draggableCursor: isDeleteMode ? 'crosshair' : null, clickableIcons: !isDeleteMode });
                }
            }, [map, isDeleteMode]);

            useEffect(() => {
                if (!map) return;
                Object.values(markersRef.current).forEach(m => m.setMap(null));
                markersRef.current = {};
                Object.values(polylinesRef.current).forEach(p => p.setMap(null));
                polylinesRef.current = {};
                
                const newOverlays = [];
                const currentZoom = map.getZoom();

                if (selectedArea) {
                    selectedArea.groups.filter(group => group.isVisible).forEach(group => {
                        const { showPolylines, showElevations, showLabels, showDescriptions, isMeasuring, isAreaMeasuring } = group;
                        const path = [];
                        const canShowAnyLabel = currentZoom >= LABEL_VISIBILITY_ZOOM_THRESHOLD;

                        (group.points || []).forEach((point, index) => {
                            const latLng = new window.google.maps.LatLng(point.lat, point.lng);
                            path.push(latLng);

                            const iconKey = point.markerIcon || 'default';
                            const iconDefinition = MARKER_ICONS[iconKey] || MARKER_ICONS['default'];
                            const markerIcon = { path: iconDefinition.path, fillColor: group.color, fillOpacity: 1, strokeWeight: iconDefinition.strokeWeight, strokeColor: '#ffffff', scale: iconDefinition.scale, anchor: iconDefinition.anchor ? new window.google.maps.Point(iconDefinition.anchor.x, iconDefinition.anchor.y) : null };

                            const marker = new window.google.maps.Marker({ 
                                position: latLng, 
                                map, 
                                draggable: !isDeleteMode, 
                                title: `نقطة ${index + 1} (${group.name})`, 
                                icon: markerIcon, 
                                cursor: isDeleteMode ? 'pointer' : 'grab',
                                visible: currentZoom >= MARKER_VISIBILITY_ZOOM_THRESHOLD
                            });
                            markersRef.current[point.id] = marker;
                            
                            let labelHtml = '';
                            if (canShowAnyLabel) {
                                let pointLabel = '';
                                let elevationLabel = '';
                                let descriptionLabel = '';

                                if (showLabels) {
                                    pointLabel = `${index + 1}`;
                                }
                                if (showElevations && point.elevation != null) {
                                    elevationLabel = `Z: ${point.elevation.toFixed(2)}m`;
                                }
                                if (showDescriptions && point.description) {
                                    descriptionLabel = point.description;
                                }

                                if (pointLabel || elevationLabel || descriptionLabel) {
                                    const mainInfo = [
                                        pointLabel ? `<span class="point-label-header">${pointLabel}</span>` : '',
                                        elevationLabel ? `<span class="point-label-body">${elevationLabel}</span>` : ''
                                    ].filter(Boolean).join(`<span class="point-label-separator mx-1">|</span>`);
                                    
                                    const descInfo = descriptionLabel ? `<div class="point-label-desc">${descriptionLabel}</div>` : '';

                                    labelHtml = `<div class="point-label-card ${darkMode ? 'dark-mode' : ''}">
                                        ${mainInfo ? `<div class="point-label-main">${mainInfo}</div>` : ''}
                                        ${descInfo}
                                    </div>`;
                                }
                            }

                            if (labelHtml) {
                                newOverlays.push({ id: `point-${point.id}`, position: latLng, text: labelHtml, styleProps: { transform: 'translate(-50%, -38px)' } });
                            }

                            const utm = convertLatLngToUtm(point.lat, point.lng, utmZone);
                            const infoContent = `<div dir="rtl"><h4>نقطة ${index + 1} (${group.name})</h4><p>Lat: ${point.lat.toFixed(6)}</p><p>Lng: ${point.lng.toFixed(6)}</p>${utm ? `<p>Easting: ${utm.easting.toFixed(2)}</p><p>Northing: ${utm.northing.toFixed(2)}</p>` : ''}<p>Elevation: ${point.elevation != null ? point.elevation.toFixed(2) : 'N/A'}</p>${point.description ? `<p>الوصف: ${point.description}</p>` : ''}</div>`;
                            
                            marker.addListener('click', () => { 
                                onActivateGroup(group.id);
                                setActivePointId(point.id);
                                if (isDeleteMode) {
                                    onDeletePointById(group.id, point.id);
                                } else {
                                    infoWindowRef.current.setContent(infoContent); 
                                    infoWindowRef.current.open(map, marker); 
                                }
                            });
                            
                            marker.addListener('dragend', (event) => {
                                const newLatLng = event.latLng;
                                let finalLat = newLatLng.lat(), finalLng = newLatLng.lng();
                                
                                const allOtherPoints = selectedArea.groups.flatMap(g => g.points).filter(p => p.id !== point.id);
                                if (group.snapEnabled && allOtherPoints.length > 0) {
                                    const closestPoint = allOtherPoints.reduce((closest, current) => {
                                        const distance = window.google.maps.geometry.spherical.computeDistanceBetween(newLatLng, new window.google.maps.LatLng(current.lat, current.lng));
                                        return distance < closest.distance ? { distance, point: current } : closest;
                                    }, { distance: Infinity, point: null });

                                    if (closestPoint.distance < SNAP_TOLERANCE_METERS) {
                                        finalLat = closestPoint.point.lat;
                                        finalLng = closestPoint.point.lng;
                                        addToast('تم الالتقاط إلى نقطة قريبة.', 'info');
                                    }
                                }
                                
                                onUpdatePoint(selectedArea.id, group.id, point.id, 'latlng', { lat: finalLat, lng: finalLng });
                            });
                        });

                        if (showPolylines && path.length > 1) {
                            const polylineStyle = currentZoom < MARKER_VISIBILITY_ZOOM_THRESHOLD 
                                ? { strokeOpacity: 1.0, strokeWeight: 5 }
                                : { strokeOpacity: 0.8, strokeWeight: 3 };

                            polylinesRef.current[group.id] = new window.google.maps.Polyline({ 
                                path, 
                                map, 
                                geodesic: true, 
                                strokeColor: group.color, 
                                ...polylineStyle 
                            });
                            
                            if (isMeasuring && currentZoom >= DISTANCE_LABEL_VISIBILITY_ZOOM_THRESHOLD) {
                                for (let i = 0; i < path.length - 1; i++) {
                                    const p1 = path[i], p2 = path[i+1];
                                    const distance = window.google.maps.geometry.spherical.computeDistanceBetween(p1, p2);
                                    const midpoint = window.google.maps.geometry.spherical.interpolate(p1, p2, 0.5);
                                    let distanceText = `${distance.toFixed(2)} م`;
                                    newOverlays.push({ id: `dist-${group.id}-${i}`, position: midpoint, text: `<div class="distance-label"><i data-lucide="ruler" style="width:12px; height:12px; display:inline-block; margin-left:4px;"></i>${distanceText}</div>`, styleProps: { transform: 'translate(-50%, -50%)' } });
                                }
                            }
                        }
                        
                        if (isAreaMeasuring && path.length >= 3) {
                            const areaPolygon = new window.google.maps.Polygon({
                                paths: path,
                                strokeColor: group.color,
                                strokeWeight: 2,
                                strokeOpacity: 0.8,
                                fillColor: group.color,
                                fillOpacity: 0.2,
                                map: map
                            });
                            polylinesRef.current[`area-fill-${group.id}`] = areaPolygon;
                            
                            if (currentZoom >= AREA_LABEL_VISIBILITY_ZOOM_THRESHOLD) {
                                const area = window.google.maps.geometry.spherical.computeArea(path);
                                const perimeter = window.google.maps.geometry.spherical.computeLength(path);
                                const bounds = new window.google.maps.LatLngBounds();
                                path.forEach(p => bounds.extend(p));
                                
                                const areaText = area > 400000 ? `${(area / 1000000).toFixed(3)} كم²` : `${area.toFixed(2)} م²`;
                                const perimeterText = perimeter > 10000 ? `${(perimeter / 1000).toFixed(2)} كم` : `${perimeter.toFixed(2)} م`;
                                
                                const areaHtml = `<div class="area-label-card ${darkMode ? 'dark-mode' : ''}">
                                    <div><i data-lucide="square" style="color:${group.color};"></i><span class="font-semibold">المساحة:</span> ${areaText}</div>
                                    <div class="mt-1 pt-1 border-t border-slate-200 dark:border-slate-700"><i data-lucide="move-horizontal" style="color:${group.color};"></i><span class="font-semibold">المحيط:</span> ${perimeterText}</div>
                                </div>`;
                                
                                newOverlays.push({ id: `area-${group.id}`, position: bounds.getCenter(), text: areaHtml, styleProps: { transform: 'translate(-50%, -50%)' } });
                            }
                        }
                    });
                }
                setMapOverlays(newOverlays);
            }, [map, selectedArea, utmZone, onUpdatePoint, darkMode, addToast, isDeleteMode, onDeletePointById, onActivateGroup, setActivePointId]);

            return (
                <>
                    <div ref={mapRef} className="w-full h-full" id="map-container"></div>
                    {mapOverlays.map(overlay => <CustomLabel key={overlay.id} map={map} {...overlay} />)}
                </>
            );
        });

        // ====================================================================
        //  FILE: src/components/map/MapOverlays.js
        // ====================================================================
        
        const MapControls = ({ onUndo, onRedo, canUndo, canRedo }) => {
            return (
                <div id="map-controls" className="absolute top-4 left-4 z-10 flex flex-col gap-2">
                    <div className="bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm p-1 rounded-full shadow-lg flex items-center border dark:border-slate-700">
                        <button onClick={onUndo} disabled={!canUndo} className="icon-button !w-10 !h-10" title="تراجع (Ctrl+Z)"><Icon name="undo-2" /></button>
                        <div className="w-px bg-slate-300 dark:bg-slate-600 my-2"></div>
                        <button onClick={onRedo} disabled={!canRedo} className="icon-button !w-10 !h-10" title="إعادة (Ctrl+Y)"><Icon name="redo-2" /></button>
                    </div>
                </div>
            );
        };

        const ActiveAreaIndicator = ({ areaName, groupName, isTakingScreenshot }) => (
            <div 
                id="active-area-indicator" 
                className={`absolute top-4 right-4 z-10 bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm p-2 px-4 rounded-lg shadow-lg border dark:border-slate-700 max-w-[calc(100vw-100px)] transition-all duration-200 ${isTakingScreenshot ? 'text-xs' : 'text-sm'}`}
            >
                <p className="truncate"><span className="font-semibold">منطقة:</span> {areaName || 'غير محدد'}</p>
                <p className="truncate"><span className="font-semibold">{isTakingScreenshot ? 'مجموعة:' : 'نشطة:'}</span> {groupName || 'غير محدد'}</p>
            </div>
        );

        // ====================================================================
        //  FILE: src/components/modals/index.js
        // ====================================================================
        
        const MarkerPickerModal = ({ onClose, onSelect, currentIconKey, previewColor = '#6b7280' }) => {
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-2xl font-bold text-gray-900 dark:text-slate-100">اختر رمز النقطة</h2>
                            <button onClick={onClose} className="icon-button"><Icon name="x" /></button>
                        </div>
                        <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
                            {Object.entries(MARKER_ICONS).map(([key, iconDef]) => (
                                <div key={key}
                                    onClick={() => onSelect(key)}
                                    className={`flex flex-col items-center justify-center p-4 rounded-lg cursor-pointer transition-all duration-200 ${currentIconKey === key ? 'bg-blue-100 dark:bg-blue-800 ring-2 ring-blue-500' : 'bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600'}`}
                                >
                                    <svg width="48" height="48" viewBox="-20 -20 40 40" fill={previewColor} stroke="white" strokeWidth="1.5">
                                        <path d={iconDef.path} />
                                    </svg>
                                    <span className="mt-2 text-sm text-center">{iconDef.label}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const DirectPasteUtmModal = ({ onClose, onProcessPaste, utmZone }) => {
            const { addToast } = useAppContext();
            const [text, setText] = useState('');

            const handleProcessClick = () => {
                if (!text.trim()) {
                    addToast("الرجاء لصق الإحداثيات في المربع.", "error");
                    return;
                }

                const { data: rows, error } = parseDelimitedText(text);
                if (error) {
                    addToast(`خطأ في التحليل: ${error}`, "error");
                }
                if (!rows || rows.length === 0) {
                    addToast("لم يتم العثور على بيانات صالحة.", "error");
                    return;
                }

                const pointsToImport = rows.map(row => {
                    if (row.length < 2) return null;
                    
                    const easting = parseFloat(row[0]);
                    const northing = parseFloat(row[1]);
                    const elevation = row.length > 2 ? parseFloat(row[2]) : null;
                    const description = row.length > 3 ? row[3] : '';

                    if (isNaN(easting) || isNaN(northing)) return null;
                    
                    const latLng = convertUtmToLatLng(easting, northing, utmZone);
                    if (!latLng) return null;
                    
                    return { id: generateUniqueId(), lat: latLng.lat, lng: latLng.lng, elevation: isNaN(elevation) ? 0.0 : elevation, utm: { easting, northing, zone: utmZone }, description, markerIcon: 'default', createdAt: new Date().toISOString() };
                }).filter(Boolean);

                if (pointsToImport.length === 0) {
                    addToast("لم يتم العثور على نقاط UTM صالحة للاستيراد.", "error");
                    return;
                }

                onProcessPaste(pointsToImport);
                onClose();
            };

            return (
                <GenericModal 
                    title="لصق مباشر لإحداثيات UTM" 
                    onClose={onClose} 
                    onConfirm={handleProcessClick} 
                    confirmText="معالجة وتوقيع"
                >
                    <p className="mb-4 text-gray-800 dark:text-slate-300">
                        قم بلصق الإحداثيات في المربع أدناه. يجب أن تكون بتنسيق (Easting, Northing, [Elevation], [Description]) مفصولة بفاصلة أو مسافة أو تاب.
                    </p>
                    <textarea
                        value={text}
                        onChange={e => setText(e.target.value)}
                        className="w-full h-48 p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 font-mono text-sm"
                        placeholder="766640.84, 3449894.71, 12.34, Point1&#10;766650.12 3449900.56 12.50 BlockA&#10;..."
                    />
                </GenericModal>
            );
        };

        const DirectPasteLatLngModal = ({ onClose, onProcessPaste, utmZone }) => {
            const { addToast } = useAppContext();
            const [text, setText] = useState('');

            const handleProcessClick = () => {
                if (!text.trim()) {
                    addToast("الرجاء لصق الإحداثيات في المربع.", "error");
                    return;
                }

                const { data: rows, error } = parseDelimitedText(text);
                if (error) {
                    addToast(`خطأ في التحليل: ${error}`, "error");
                }
                if (!rows || rows.length === 0) {
                    addToast("لم يتم العثور على بيانات صالحة.", "error");
                    return;
                }

                const pointsToImport = rows.map(row => {
                    if (row.length < 2) return null;
                    
                    const lat = parseFloat(row[0]);
                    const lng = parseFloat(row[1]);
                    const description = row.length > 2 ? row[2] : '';

                    if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) return null;
                    
                    const utm = convertLatLngToUtm(lat, lng, utmZone);
                    if (!utm) return null;
                    
                    return { id: generateUniqueId(), lat, lng, elevation: 0.0, utm, description, markerIcon: 'default', createdAt: new Date().toISOString() };
                }).filter(Boolean);

                if (pointsToImport.length === 0) {
                    addToast("لم يتم العثور على نقاط Lat/Lng صالحة للاستيراد.", "error");
                    return;
                }

                onProcessPaste(pointsToImport);
                onClose();
            };

            return (
                <GenericModal 
                    title="لصق مباشر لإحداثيات Lat/Long" 
                    onClose={onClose} 
                    onConfirm={handleProcessClick} 
                    confirmText="معالجة وتوقيع"
                >
                    <p className="mb-4 text-gray-800 dark:text-slate-300">
                        قم بلصق الإحداثيات في المربع أدناه. يجب أن تكون بتنسيق (Latitude, Longitude, [Description]) مفصولة بفاصلة أو مسافة أو تاب.
                    </p>
                    <textarea
                        value={text}
                        onChange={e => setText(e.target.value)}
                        className="w-full h-48 p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 font-mono text-sm"
                        placeholder="30.0443, 31.2357, Tahrir Square&#10;29.9792 31.1342 Pyramid Giza&#10;..."
                        dir="ltr"
                    />
                </GenericModal>
            );
        };

        const ImportChoiceModal = ({ onClose, onPasteClick, onFileClick }) => {
            return (
                <GenericModal
                    title="استيراد / تحميل"
                    onClose={onClose}
                    showConfirm={false}
                    showCancel={true}
                    cancelText="إغلاق"
                >
                    <div className="flex flex-col space-y-4">
                        <p className="text-gray-800 dark:text-slate-300">اختر طريقة إدخال البيانات:</p>
                        <button onClick={onPasteClick} className="button-secondary flex items-center justify-center w-full !py-3 text-base">
                            <Icon name="clipboard-paste" className="ml-2" />
                            لصق الإحداثيات مباشرة
                        </button>
                        <button onClick={onFileClick} className="button-primary flex items-center justify-center w-full !py-3 text-base">
                            <Icon name="upload" className="ml-2" />
                            تحميل ملف
                        </button>
                    </div>
                </GenericModal>
            );
        };
        
        const ExportChoiceModal = ({ onClose, onExportClick, onSaveClick, onDxfClick }) => {
            return (
                <GenericModal
                    title="تصدير / حفظ"
                    onClose={onClose}
                    showConfirm={false}
                    showCancel={true}
                    cancelText="إغلاق"
                >
                    <div className="flex flex-col space-y-4">
                        <p className="text-gray-800 dark:text-slate-300">اختر الإجراء المطلوب:</p>
                        <button onClick={onExportClick} className="button-secondary flex items-center justify-center w-full !py-3 text-base">
                            <Icon name="file-output" className="ml-2" />
                            تصدير النقاط (CSV, SCR...)
                        </button>
                        <button onClick={onDxfClick} className="button-secondary flex items-center justify-center w-full !py-3 text-base">
                            <Icon name="file-axis-3d" className="ml-2" />
                            تصدير إلى DXF
                        </button>
                        <button onClick={onSaveClick} className="button-primary flex items-center justify-center w-full !py-3 text-base">
                            <Icon name="save-all" className="ml-2" />
                            حفظ المشروع بالكامل (.hemap)
                        </button>
                    </div>
                </GenericModal>
            );
        };

        const ExportPointsModal = ({ workAreas, onClose, onExport, initialFormat = 'csv' }) => {
            const { addToast } = useAppContext();
            const [selectedIds, setSelectedIds] = useState({});
            const [exportFormat, setExportFormat] = useState(initialFormat);
            const [delimiter, setDelimiter] = useState(',');
            const [entityType, setEntityType] = useState('pline'); // Renamed from acadScriptType
            const [addCsvDescription, setAddCsvDescription] = useState(false);
            const [generatedCommand, setGeneratedCommand] = useState('');
            
            const [fileName, setFileName] = useState('تصدير_نقاط');
            const [fileExtension, setFileExtension] = useState('csv');

            useEffect(() => {
                if (exportFormat === 'csv') {
                    setFileName('تصدير_نقاط');
                    setFileExtension('csv');
                } else if (exportFormat === 'acad_script') {
                    setFileName(`سكريبت_${entityType}`);
                    setFileExtension('scr');
                } else if (exportFormat === 'dxf') {
                    setFileName(`رسم_${entityType}`);
                    setFileExtension('dxf');
                }
            }, [exportFormat, entityType]);

            const handleSelectionChange = (id, type) => {
                setSelectedIds(prev => {
                    const newSelection = { ...prev };
                    if (newSelection[id]) {
                        delete newSelection[id];
                        if (type === 'area') {
                            const area = workAreas.find(a => a.id === id);
                            area?.groups.forEach(g => delete newSelection[`group-${g.id}`]);
                        }
                    } else {
                        newSelection[id] = true;
                        if (type === 'area') {
                            const area = workAreas.find(a => a.id === id);
                            area?.groups.forEach(g => newSelection[`group-${g.id}`] = true);
                        }
                    }
                    return newSelection;
                });
            };

            const handleExportClick = () => {
                if (!fileName || fileName.trim() === '') {
                    addToast('الرجاء إدخال اسم ملف صالح.', 'error');
                    return;
                }
                const options = { selectedIds, exportFormat, delimiter, fileExtension, entityType, addCsvDescription };
                const result = onExport(options, fileName.trim());

                if (exportFormat === 'acad_script') {
                    if (result) {
                        setGeneratedCommand(result);
                    }
                } else {
                    onClose();
                }
            };

            const copyCommandToClipboard = () => {
                if (!generatedCommand) return;
                const textArea = document.createElement("textarea");
                textArea.value = generatedCommand;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    addToast('تم نسخ الأمر إلى الحافظة.', 'success');
                } catch (err) {
                    addToast('فشل النسخ إلى الحافظة.', 'error');
                }
                document.body.removeChild(textArea);
            };

            const handleDownloadScript = () => {
                if (!generatedCommand || !fileName) return;
                downloadFile(generatedCommand, `${fileName.trim()}.scr`, 'application/octet-stream');
                addToast('تم تنزيل ملف السكريبت.', 'success');
            };

            return (
                <GenericModal title="تصدير النقاط" onClose={onClose} onConfirm={handleExportClick} confirmText={exportFormat === 'acad_script' ? 'توليد الأمر' : 'تصدير'}>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 className="text-lg font-semibold mb-2">1. تحديد النطاق</h3>
                            <div className="p-2 border rounded-md h-64 overflow-y-auto dark:border-slate-600">
                                {workAreas.map(area => (
                                    <div key={area.id} className="mb-2">
                                        <div className="flex items-center">
                                            <input type="checkbox" id={`area-${area.id}`} checked={!!selectedIds[area.id]} onChange={() => handleSelectionChange(area.id, 'area')} className="ml-2" />
                                            <label htmlFor={`area-${area.id}`} className="font-bold">{area.name}</label>
                                        </div>
                                        <div className="mr-6 mt-1 space-y-1">
                                            {area.groups.map(group => (
                                                <div key={group.id} className="flex items-center">
                                                    <input type="checkbox" id={`group-${group.id}`} checked={!!selectedIds[`group-${group.id}`]} onChange={() => handleSelectionChange(`group-${group.id}`, 'group')} className="ml-2" />
                                                    <label htmlFor={`group-${group.id}`}>{group.name}</label>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div>
                            <h3 className="text-lg font-semibold mb-2">2. تحديد الصيغة والإعدادات</h3>
                            <div className="space-y-2">
                                <div className="flex items-center"><input type="radio" id="format-csv" name="format" value="csv" checked={exportFormat === 'csv'} onChange={e => setExportFormat(e.target.value)} className="ml-2" /><label htmlFor="format-csv">ملف نصي (CSV/TXT)</label></div>
                                <div className="flex items-center"><input type="radio" id="format-acad" name="format" value="acad_script" checked={exportFormat === 'acad_script'} onChange={e => setExportFormat(e.target.value)} className="ml-2" /><label htmlFor="format-acad">سكريبت AutoCAD (.scr)</label></div>
                                <div className="flex items-center"><input type="radio" id="format-dxf" name="format" value="dxf" checked={exportFormat === 'dxf'} onChange={e => setExportFormat(e.target.value)} className="ml-2" /><label htmlFor="format-dxf">ملف DXF</label></div>
                            </div>
                            
                            <div className="mt-4">
                                <label htmlFor="file-name-input" className="block text-sm font-medium mb-1">اسم الملف</label>
                                <div className="flex">
                                    <input 
                                        id="file-name-input"
                                        type="text" 
                                        value={fileName} 
                                        onChange={e => setFileName(e.target.value)} 
                                        className="block w-full p-2 border rounded-r-md dark:bg-slate-700 dark:border-slate-600 focus:ring-2 focus:ring-blue-500" 
                                    />
                                    <span className="inline-flex items-center px-3 rounded-l-md border border-r-0 border-gray-300 bg-gray-50 text-gray-500 text-sm dark:bg-slate-800 dark:border-slate-600 dark:text-slate-400">
                                        .{fileExtension}
                                    </span>
                                </div>
                            </div>
                            
                            {exportFormat === 'csv' && (
                                <div className="mt-4 space-y-4">
                                    <div>
                                        <label htmlFor="delimiter" className="block text-sm font-medium mb-1">الفاصلة</label>
                                        <select id="delimiter" value={delimiter} onChange={e => setDelimiter(e.target.value)} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                            <option value=",">فاصلة (,)</option>
                                            <option value=" ">مسافة (Space)</option>
                                            <option value="\t">تاب (Tab)</option>
                                            <option value=";">فاصلة منقوطة (;)</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label htmlFor="file-extension-select" className="block text-sm font-medium mb-1">نوع الملف</label>
                                        <select id="file-extension-select" value={fileExtension} onChange={e => setFileExtension(e.target.value)} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                            <option value="csv">ملف CSV</option>
                                            <option value="txt">ملف نصي TXT</option>
                                        </select>
                                    </div>
                                    <div className="flex items-center">
                                        <input type="checkbox" id="add-csv-desc" checked={addCsvDescription} onChange={e => setAddCsvDescription(e.target.checked)} className="ml-2" />
                                        <label htmlFor="add-csv-desc">تضمين الوصف (تنسيق P,E,N,Z,D)</label>
                                    </div>
                                </div>
                            )}
                            {(exportFormat === 'acad_script' || exportFormat === 'dxf') && (
                                <div className="mt-4 space-y-4">
                                    <div>
                                        <label htmlFor="entity-type" className="block text-sm font-medium mb-1">نوع الكيان</label>
                                        <select id="entity-type" value={entityType} onChange={e => setEntityType(e.target.value)} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                            <option value="pline">خطوط متصلة (Polyline)</option>
                                            <option value="points">نقاط (Points)</option>
                                        </select>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    {generatedCommand && (
                        <div className="mt-4">
                            <h4 className="font-semibold mb-1">الأمر المولد:</h4>
                            <textarea readOnly value={generatedCommand} className="w-full h-24 p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 font-mono text-sm" />
                            <div className="flex items-center gap-2 mt-2">
                                <button onClick={copyCommandToClipboard} className="button-secondary">
                                    <Icon name="copy" size={16} className="inline-block ml-1" />
                                    نسخ الأمر
                                </button>
                                <button onClick={handleDownloadScript} className="button-primary">
                                    <Icon name="download" size={16} className="inline-block ml-1" />
                                    تنزيل ملف .scr
                                </button>
                            </div>
                        </div>
                    )}
                </GenericModal>
            );
        };
        
        const PdfOptionsModal = ({ onClose, onConfirm, groups, selectedGroupId }) => {
            const { addToast } = useAppContext();
            const [reportTitle, setReportTitle] = useState('Technical Report');
            
            const [selectedGroupIds, setSelectedGroupIds] = useState(() => {
                const initialSelection = {};
                if (selectedGroupId) {
                    initialSelection[selectedGroupId] = true;
                }
                return initialSelection;
            });

            const handleGroupSelectionChange = (groupId) => {
                setSelectedGroupIds(prev => {
                    const newSelection = {...prev};
                    if (newSelection[groupId]) {
                        delete newSelection[groupId];
                    } else {
                        newSelection[groupId] = true;
                    }
                    return newSelection;
                });
            };

            const handleConfirm = () => {
                const ids = Object.keys(selectedGroupIds);
                if (ids.length === 0) {
                    addToast('Please select at least one group to include in the report.', 'error');
                    return;
                }
                onConfirm({ reportTitle, selectedGroupIds: ids });
                onClose();
            };

            return (
                <GenericModal
                    title="PDF Report Options"
                    onClose={onClose}
                    onConfirm={handleConfirm}
                    confirmText="Generate Report"
                >
                    <div className="space-y-4" dir="ltr">
                        <div>
                            <label htmlFor="report-title" className="block text-sm font-medium mb-1 text-gray-700 dark:text-slate-200">Report Title</label>
                            <input
                                id="report-title"
                                type="text"
                                value={reportTitle}
                                onChange={e => setReportTitle(e.target.value)}
                                className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600"
                            />
                        </div>
                        <div>
                            <h4 className="text-sm font-medium mb-2 text-gray-700 dark:text-slate-200">Select Groups to Include</h4>
                            <div className="max-h-48 overflow-y-auto p-2 border rounded-md dark:border-slate-600">
                                {groups.map(group => (
                                    <div key={group.id} className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id={`pdf-group-${group.id}`}
                                            checked={!!selectedGroupIds[group.id]}
                                            onChange={() => handleGroupSelectionChange(group.id)}
                                            className="mr-2"
                                        />
                                        <label htmlFor={`pdf-group-${group.id}`}>{group.name}</label>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </GenericModal>
            );
        };

        const ScreenshotOptionsModal = ({ onClose, onConfirm }) => {
            const [showPanel, setShowPanel] = useState(true);
            const [showTimestamp, setShowTimestamp] = useState(true);

            const handleConfirm = () => {
                onConfirm({ showPanel, showTimestamp });
            };

            return (
                <GenericModal title="إعدادات لقطة الشاشة" onClose={onClose} onConfirm={handleConfirm} confirmText="التقاط الصورة">
                    <div className="space-y-4">
                        <div className="flex items-center">
                            <input id="show-panel-check" type="checkbox" checked={showPanel} onChange={e => setShowPanel(e.target.checked)} className="ml-3 h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500" />
                            <label htmlFor="show-panel-check" className="text-base text-gray-800 dark:text-slate-200">إظهار معلومات المشروع</label>
                        </div>
                        <div className="flex items-center">
                            <input id="show-timestamp-check" type="checkbox" checked={showTimestamp} onChange={e => setShowTimestamp(e.target.checked)} className="ml-3 h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500" />
                            <label htmlFor="show-timestamp-check" className="text-base text-gray-800 dark:text-slate-200">إظهار الوقت والتاريخ</label>
                        </div>
                    </div>
                </GenericModal>
            );
        };

        const PointDetailSheet = ({ point, group, onClose, onUpdate, onDelete, onOpenMarkerPicker }) => {
            if (!point || !group) return null;

            const handleSheetClick = (e) => e.stopPropagation();

            return (
                <>
                    <div className="fixed inset-0 bg-black/30 z-20 lg:hidden" onClick={onClose} style={{ animation: 'fade-in 0.3s' }}></div>
                    <div 
                        className="fixed bottom-0 right-0 left-0 bg-white dark:bg-slate-800 p-4 rounded-t-2xl shadow-2xl z-30 lg:hidden"
                        style={{ animation: 'slide-in-up 0.3s ease-out forwards' }}
                        onClick={handleSheetClick}
                    >
                        <div className="flex justify-center mb-2">
                            <div className="w-10 h-1.5 bg-slate-300 dark:bg-slate-600 rounded-full"></div>
                        </div>
                        <button onClick={onClose} className="absolute top-3 right-3 icon-button !w-10 !h-10"><Icon name="x" /></button>

                        <div className="flex items-center gap-3 mb-4">
                            <div className="w-10 h-10 flex-shrink-0">
                                 <svg width="40" height="40" viewBox="-20 -20 40 40" fill={group.color} stroke="white" strokeWidth="1.5">
                                    <path d={(MARKER_ICONS[point.markerIcon] || MARKER_ICONS['default']).path} />
                                </svg>
                            </div>
                            <div>
                                <p className="text-lg font-bold">نقطة {point.number || ''}</p>
                                <p className="text-sm text-slate-500 dark:text-slate-400">{group.name}</p>
                            </div>
                        </div>

                        <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-sm font-mono mb-4 bg-slate-50 dark:bg-slate-900/50 p-3 rounded-lg">
                            <div>E (X): <span className="font-semibold text-slate-800 dark:text-slate-200">{point.utm?.easting?.toFixed(2) || 'N/A'}</span></div>
                            <div>N (Y): <span className="font-semibold text-slate-800 dark:text-slate-200">{point.utm?.northing?.toFixed(2) || 'N/A'}</span></div>
                            <div>Elev (Z): <span className="font-semibold text-slate-800 dark:text-slate-200">{point.elevation?.toFixed(2) || 'N/A'}</span></div>
                        </div>
                        
                        <div className="mb-4">
                             <textarea
                                value={point.description || ''}
                                onChange={(e) => onUpdate('description', e.target.value)}
                                placeholder="أضف وصفًا..."
                                className="w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 text-sm h-16 resize-none"
                            />
                        </div>

                        <div className="flex justify-between items-center gap-2">
                            <button onClick={onOpenMarkerPicker} className="button-secondary flex-1 flex items-center justify-center text-sm !py-2"><Icon name="shapes" size={16} className="ml-2"/>تغيير الرمز</button>
                            <button onClick={onDelete} className="button-secondary bg-red-600 hover:bg-red-700 flex-1 flex items-center justify-center text-sm !py-2"><Icon name="trash-2" size={16} className="ml-2"/>حذف</button>
                        </div>
                    </div>
                </>
            );
        };

        const ToolsSheet = ({ settings, onClose, onUpdateSettings, onToggleDeleteMode, onOpenScreenshotModal, isZoomedInEnough }) => {
            const { showPolylines, showElevations, showLabels, showDescriptions, isMeasuring, isAreaMeasuring, snapEnabled, isDeleteMode } = settings;
            
            const handleToolClick = (action, toolId) => {
                action();
                if (toolId === 'screenshot') {
                    onClose();
                }
            };

            const tools = [
                // Row 1
                { id: 'measure', icon: 'ruler', title: 'قياس المسافة', action: () => onUpdateSettings('isMeasuring', !isMeasuring), active: isMeasuring },
                { id: 'area', icon: 'square', title: 'قياس المساحة', action: () => onUpdateSettings('isAreaMeasuring', !isAreaMeasuring), active: isAreaMeasuring },
                { id: 'snap', icon: 'magnet', title: 'تفعيل الالتقاط', action: () => onUpdateSettings('snapEnabled', !snapEnabled), active: snapEnabled },
                // Row 2
                { id: 'showLabels', icon: 'hash', title: 'إظهار التسلسل', action: () => onUpdateSettings('showLabels', !showLabels), active: showLabels, disabled: !isZoomedInEnough },
                { id: 'polyline', icon: 'git-commit', title: 'إظهار الخطوط', action: () => onUpdateSettings('showPolylines', !showPolylines), active: showPolylines },
                { id: 'elevation', icon: 'text', title: 'إظهار المناسيب', action: () => onUpdateSettings('showElevations', !showElevations), active: showElevations, disabled: !isZoomedInEnough },
                // Row 3
                { id: 'showDescription', icon: 'message-square-text', title: 'إظهار الوصف', action: () => onUpdateSettings('showDescriptions', !showDescriptions), active: showDescriptions, disabled: !isZoomedInEnough },
                { id: 'delete', icon: 'trash-2', title: 'حذف نقطة بالنقر', action: onToggleDeleteMode, active: isDeleteMode, danger: true },
                { id: 'screenshot', icon: 'camera', title: 'أخذ لقطة شاشة', action: onOpenScreenshotModal, active: false },
            ];
            
            return (
                 <>
                    <div className="fixed inset-0 bg-black/30 z-40" onClick={onClose} style={{ animation: 'fade-in 0.3s' }}></div>
                    <div 
                        className="fixed bottom-0 right-0 left-0 bg-white dark:bg-slate-800 p-4 rounded-t-2xl shadow-2xl z-50"
                        style={{ animation: 'slide-in-up 0.3s ease-out forwards' }}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <div className="flex justify-center mb-4" onClick={onClose}>
                            <div className="w-10 h-1.5 bg-slate-300 dark:bg-slate-600 rounded-full"></div>
                        </div>
                        <h3 className="text-lg font-bold text-center mb-4">أدوات الخريطة</h3>
                        <div className="grid grid-cols-3 gap-4">
                            {tools.map(tool => (
                                <button 
                                    key={tool.id} 
                                    onClick={() => handleToolClick(tool.action, tool.id)} 
                                    disabled={tool.disabled}
                                    className={`flex flex-col items-center justify-center gap-2 p-3 rounded-lg transition-colors ${tool.active ? (tool.danger ? 'bg-red-500 text-white' : 'bg-blue-600 text-white') : 'bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600'} ${tool.disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                                >
                                    <Icon name={tool.icon} size={28} />
                                    <span className="text-xs text-center">{tool.title}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                </>
            );
        };
        
        const ToolsModal = ({ settings, onClose, onUpdateSettings, onToggleDeleteMode, onOpenScreenshotModal, isZoomedInEnough }) => {
            const { showPolylines, showElevations, showLabels, showDescriptions, isMeasuring, isAreaMeasuring, snapEnabled, isDeleteMode } = settings;
            
            const tools = [
                 // Row 1
                { id: 'measure', icon: 'ruler', title: 'قياس المسافة', action: () => onUpdateSettings('isMeasuring', !isMeasuring), active: isMeasuring },
                { id: 'area', icon: 'square', title: 'قياس المساحة', action: () => onUpdateSettings('isAreaMeasuring', !isAreaMeasuring), active: isAreaMeasuring },
                { id: 'snap', icon: 'magnet', title: 'تفعيل الالتقاط', action: () => onUpdateSettings('snapEnabled', !snapEnabled), active: snapEnabled },
                // Row 2
                { id: 'showLabels', icon: 'hash', title: 'إظهار التسلسل', action: () => onUpdateSettings('showLabels', !showLabels), active: showLabels, disabled: !isZoomedInEnough },
                { id: 'polyline', icon: 'git-commit', title: 'إظهار الخطوط', action: () => onUpdateSettings('showPolylines', !showPolylines), active: showPolylines },
                { id: 'elevation', icon: 'text', title: 'إظهار المناسيب', action: () => onUpdateSettings('showElevations', !showElevations), active: showElevations, disabled: !isZoomedInEnough },
                // Row 3
                { id: 'showDescription', icon: 'message-square-text', title: 'إظهار الوصف', action: () => onUpdateSettings('showDescriptions', !showDescriptions), active: showDescriptions, disabled: !isZoomedInEnough },
                { id: 'delete', icon: 'trash-2', title: 'حذف نقطة بالنقر', action: onToggleDeleteMode, active: isDeleteMode, danger: true },
                { id: 'screenshot', icon: 'camera', title: 'لقطة شاشة', action: onOpenScreenshotModal, active: false },
            ];

            return (
                <GenericModal
                    title="أدوات الخريطة"
                    onClose={onClose}
                    showConfirm={false}
                    showCancel={true}
                    cancelText="إغلاق"
                >
                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-4">
                        {tools.map(tool => (
                            <button 
                                key={tool.id} 
                                onClick={tool.action} 
                                disabled={tool.disabled}
                                className={`flex flex-col items-center justify-center gap-2 p-4 rounded-lg transition-colors ${tool.active ? (tool.danger ? 'bg-red-500 text-white' : 'bg-blue-600 text-white') : 'bg-slate-100 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600'} ${tool.disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                                <Icon name={tool.icon} size={28} />
                                <span className="text-xs text-center font-semibold">{tool.title}</span>
                            </button>
                        ))}
                    </div>
                </GenericModal>
            );
        };
        
        // ====================================================================
        //  FILE: src/components/other/ScreenshotStamp.js
        // ====================================================================
        const ScreenshotStamp = ({ isVisible, areaName, groupName, options }) => {
            if (!options) return null;
        
            const stampStyle = {
                position: 'absolute',
                bottom: '2rem',
                right: '1rem',
                zIndex: 30, 
                transition: 'opacity 0.2s ease-in-out',
                opacity: isVisible ? 1 : 0,
                pointerEvents: 'none', 
            };
        
            return (
                <div style={stampStyle} className="bg-white/80 dark:bg-slate-900/80 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-slate-200 dark:border-slate-700 flex items-center gap-3">
                    <Icon name="map-pin" className="text-blue-600" size={32} />
                    <div className="text-right">
                        <p className="font-bold text-sm text-slate-800 dark:text-slate-100">تطبيق الخرائط الهندسية</p>
                        <p className="text-xs text-slate-600 dark:text-slate-400">تطوير: م. حمدي وحيد</p>
                        {options.showPanel && (
                            <p className="text-xs text-slate-500 dark:text-slate-400 border-t border-slate-200 dark:border-slate-700 pt-1 mt-1">
                                <span className="font-semibold">منطقة:</span> {areaName || 'غير محدد'} | <span className="font-semibold">مجموعة:</span> {groupName || 'غير محدد'}
                            </p>
                        )}
                        {options.showTimestamp && (
                            <p className="text-xs text-slate-500 dark:text-slate-400 font-mono mt-1">
                                {new Date().toLocaleString('ar-EG-u-nu-latn', { dateStyle: 'full', timeStyle: 'medium' })}
                            </p>
                        )}
                    </div>
                </div>
            );
        };

        // ====================================================================
        //  FILE: src/App.js
        // ====================================================================
        function App() {
            // --- تعريف الحالات (States) ---
            const [workAreas, setWorkAreas, undo, redo, canUndo, canRedo] = useHistoryState([]);
            const [selectedWorkAreaId, setSelectedWorkAreaId] = useState(null);
            const [selectedGroupId, setSelectedGroupId] = useState(null);
            const [activePointId, setActivePointId] = useState(null);
            const [isMapFullScreen, setIsMapFullScreen] = useState(false);
            const [isSidebarOpen, setIsSidebarOpen] = useState(false);
            const [isDeleteMode, setIsDeleteMode] = useState(false);
            const [isTableViewActive, setIsTableViewActive] = useState(false);
            const [isDesktopTableExpanded, setIsDesktopTableExpanded] = useState(false);
            const [isToolsSheetOpen, setIsToolsSheetOpen] = useState(false);
            const [currentZoom, setCurrentZoom] = useState(DEFAULT_MAP_ZOOM);
            const { utmZone, setUtmZone, addToast, coordinateSystem } = useAppContext();
            const [modal, setModal] = useState({ type: null, props: {} });
            const [isTakingScreenshot, setIsTakingScreenshot] = useState(false);
            const [screenshotOptions, setScreenshotOptions] = useState({ showPanel: true, showTimestamp: true });
            const mapApiRef = useRef(null);
            const fileInputRef = useRef(null);
            
            const isZoomedInEnough = currentZoom >= LABEL_VISIBILITY_ZOOM_THRESHOLD;

            const closeModal = useCallback(() => setModal({ type: null, props: {} }), []);

            const { activePoint, activePointGroup } = useMemo(() => {
                if (!activePointId) return { activePoint: null, activePointGroup: null };
                for (const area of workAreas) {
                    for (const group of area.groups) {
                        const pointIndex = group.points.findIndex(p => p.id === activePointId);
                        if (pointIndex !== -1) {
                            const point = group.points[pointIndex];
                            const pointWithNumber = {...point, number: pointIndex + 1 };
                            return { activePoint: pointWithNumber, activePointGroup: group };
                        }
                    }
                }
                return { activePoint: null, activePointGroup: null };
            }, [activePointId, workAreas]);

            const handleKeyDown = useCallback((event) => {
                if (modal.type || ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                    return;
                }
                if (event.ctrlKey) {
                    if (event.key.toLowerCase() === 'z') {
                        event.preventDefault();
                        undo();
                    } else if (event.key.toLowerCase() === 'y') {
                        event.preventDefault();
                        redo();
                    }
                }
            }, [undo, redo, modal.type]);

            useEffect(() => {
                window.addEventListener('keydown', handleKeyDown);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                };
            }, [handleKeyDown]);
            
            useEffect(() => {
                try {
                    const saved = localStorage.getItem('workAreas');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            setWorkAreas(parsed.map(area => ({
                                ...area,
                                groups: area.groups.map(g => ({...DEFAULT_GROUP_SETTINGS, isVisible: g.isVisible !== false, ...g}))
                            })));
                            const savedAreaId = localStorage.getItem('selectedWorkAreaId') || parsed[0]?.id;
                            setSelectedWorkAreaId(savedAreaId);
                            const savedGroupId = localStorage.getItem('selectedGroupId') || parsed.find(a => a.id === savedAreaId)?.groups[0]?.id || null;
                            setSelectedGroupId(savedGroupId);
                            return;
                        }
                    }
                } catch (e) { console.error("Failed to load work areas", e); }
                
                const newAreaId = generateUniqueId();
                const newGroupId = generateUniqueId();
                const defaultArea = { 
                    id: newAreaId, 
                    name: 'القاهرة ، مصر', 
                    createdAt: new Date().toISOString(), 
                    groups: [{ id: newGroupId, name: 'ميدان التحرير', color: POINT_GROUP_COLORS[0], points: [], ...DEFAULT_GROUP_SETTINGS }],
                };
                setWorkAreas([defaultArea]);
                setSelectedWorkAreaId(newAreaId);
                setSelectedGroupId(newGroupId);
            }, []);

            useEffect(() => {
                localStorage.setItem('workAreas', JSON.stringify(workAreas));
                if (selectedWorkAreaId) localStorage.setItem('selectedWorkAreaId', selectedWorkAreaId);
                if (selectedGroupId) localStorage.setItem('selectedGroupId', selectedGroupId);
            }, [workAreas, selectedWorkAreaId, selectedGroupId]);

            const selectedArea = useMemo(() => workAreas.find(a => a.id === selectedWorkAreaId), [workAreas, selectedWorkAreaId]);
            const selectedGroup = useMemo(() => selectedArea?.groups.find(g => g.id === selectedGroupId), [selectedArea, selectedGroupId]);
            
            const handleSelectArea = (areaId) => {
                setSelectedWorkAreaId(areaId);
                const area = workAreas.find(a => a.id === areaId);
                setSelectedGroupId(area?.groups[0]?.id || null);
                setActivePointId(null);
                const allPoints = area?.groups.flatMap(g => g.points) || [];
                if (allPoints.length > 0) {
                    mapApiRef.current?.zoomToBounds(allPoints);
                } else {
                    mapApiRef.current?.resetView();
                }
            };

            const handleAddNewArea = () => {
                const newName = `منطقة عمل ${workAreas.length + 1}`;
                const newAreaId = generateUniqueId();
                const newGroupId = generateUniqueId();
                const newArea = { 
                    id: newAreaId, 
                    name: newName, 
                    createdAt: new Date().toISOString(),
                    groups: [{ id: newGroupId, name: 'مجموعة نقاط 1', color: POINT_GROUP_COLORS[0], points: [], ...DEFAULT_GROUP_SETTINGS }]
                };
                setWorkAreas(p => [...p, newArea]);
                setSelectedWorkAreaId(newAreaId);
                setSelectedGroupId(newGroupId);
                setActivePointId(null);
                mapApiRef.current?.resetView();
                addToast(`تمت إضافة "${newName}" بنجاح`, 'success');
            };
            
            const handleDeleteArea = (id) => { 
                const newWorkAreas = workAreas.filter(a => a.id !== id);
                setWorkAreas(newWorkAreas);
                if (selectedWorkAreaId === id) {
                    setSelectedWorkAreaId(newWorkAreas[0]?.id || null);
                    setSelectedGroupId(newWorkAreas[0]?.groups[0]?.id || null);
                }
            };

            const handleRenameArea = (id, name) => { 
                setWorkAreas(prev => prev.map(a => a.id === id ? {...a, name} : a));
            };

            const handleAddNewGroup = (areaId) => {
                setWorkAreas(prev => prev.map(a => {
                    if (a.id !== areaId) return a;
                    const newName = `مجموعة نقاط ${a.groups.length + 1}`;
                    const newGroup = {id: generateUniqueId(), name: newName, color: POINT_GROUP_COLORS[a.groups.length % POINT_GROUP_COLORS.length], points:[], ...DEFAULT_GROUP_SETTINGS};
                    setSelectedGroupId(newGroup.id);
                    addToast(`تمت إضافة "${newName}" بنجاح`, 'success');
                    return {...a, groups: [...a.groups, newGroup]};
                }));
            };

            const handleDeleteGroup = (areaId, groupId) => {
                setWorkAreas(prev => prev.map(area => {
                    if (area.id !== areaId) return area;
                    const newGroups = area.groups.filter(g => g.id !== groupId);
                    if(selectedGroupId === groupId){
                        setSelectedGroupId(newGroups[0]?.id || null);
                        setActivePointId(null);
                    }
                    return {...area, groups: newGroups};
                }));
            };
            
            const handleRenameGroup = (areaId, groupId, name) => {
                 setWorkAreas(prev => prev.map(a => a.id === areaId ? {...a, groups: a.groups.map(g => g.id === groupId ? {...g, name} : g)} : a));
            };

            const handleAddPoint = useCallback(async (lat, lng) => {
                if (isDeleteMode) { addToast('وضع الحذف مفعل. قم بإلغاء تفعيله لإضافة نقاط.', 'info'); return null; }
                if (!selectedArea) { addToast('الرجاء تحديد منطقة عمل أولاً.', 'error'); return null; }
                
                let finalLat = lat, finalLng = lng, finalElevation = 0.0, finalUtm = null, snapped = false;
                
                const allPoints = selectedArea.groups.flatMap(g => g.points);
                if (selectedGroup?.snapEnabled && allPoints.length > 0) {
                    const clickLatLng = new window.google.maps.LatLng(lat, lng);
                    const closestPoint = allPoints.reduce((closest, current) => {
                        const distance = window.google.maps.geometry.spherical.computeDistanceBetween(clickLatLng, new window.google.maps.LatLng(current.lat, current.lng));
                        return distance < closest.distance ? { distance, point: current } : closest;
                    }, { distance: Infinity, point: null });

                    if (closestPoint.distance < SNAP_TOLERANCE_METERS) {
                        finalLat = closestPoint.point.lat;
                        finalLng = closestPoint.point.lng;
                        finalElevation = closestPoint.point.elevation;
                        finalUtm = closestPoint.point.utm;
                        snapped = true;
                        addToast('تم الالتقاط إلى نقطة قريبة.', 'info');
                    }
                }

                if (!snapped) {
                    if (selectedGroup?.showElevations) {
                        addToast('جاري جلب المنسوب...', 'info');
                        const { elevation, status } = await getElevation({ lat: finalLat, lng: finalLng });
                        if(status !== 'OK') addToast(`فشل جلب المنسوب (${status}).`, 'error');
                        finalElevation = elevation ?? 0.0;
                    } else {
                        finalElevation = 0.0;
                    }
                    finalUtm = convertLatLngToUtm(finalLat, finalLng, utmZone);
                }

                const newPoint = { id: generateUniqueId(), lat: finalLat, lng: finalLng, elevation: finalElevation, utm: finalUtm, description: '', markerIcon: 'default', createdAt: new Date().toISOString() };
                
                setWorkAreas(prevAreas => {
                    return prevAreas.map(area => {
                        if (area.id !== selectedArea.id) return area;
                        
                        let targetGroupFound = false;
                        const updatedGroups = area.groups.map(g => {
                            if (g.id === selectedGroupId) {
                                targetGroupFound = true;
                                return { ...g, points: [...g.points, newPoint] };
                            }
                            return g;
                        });
                        
                        if (!targetGroupFound && updatedGroups.length > 0) {
                            updatedGroups[0].points.push(newPoint);
                        } else if (updatedGroups.length === 0) {
                            const newGroupId = generateUniqueId();
                            updatedGroups.push({ id: newGroupId, name: 'مجموعة نقاط 1', color: POINT_GROUP_COLORS[0], points: [newPoint], ...DEFAULT_GROUP_SETTINGS });
                            setSelectedGroupId(newGroupId);
                        }
                        
                        return { ...area, groups: updatedGroups, lastModifiedAt: new Date().toISOString() };
                    });
                });

                if (!snapped) addToast('تمت إضافة النقطة.', 'success');
                return newPoint.id;
            }, [selectedArea, selectedGroupId, utmZone, addToast, selectedGroup, isDeleteMode, setWorkAreas]);

            const handleUpdatePoint = useCallback(async (areaId, groupId, pointId, field, value) => {
                let newPointData = {};
                
                if (field === 'latlng') {
                    const area = workAreas.find(a => a.id === areaId);
                    const group = area?.groups.find(g => g.id === groupId);
                    const point = group?.points.find(p => p.id === pointId);

                    let finalElevation = point?.elevation ?? 0;

                    if (group?.showElevations) {
                        const { elevation, status } = await getElevation(value);
                        if (status !== 'OK') addToast(`تعذر تحديث المنسوب (${status}).`, 'error');
                        finalElevation = elevation ?? point?.elevation ?? 0;
                    }
                    
                    newPointData = { lat: value.lat, lng: value.lng, utm: convertLatLngToUtm(value.lat, value.lng, utmZone), elevation: finalElevation };
                } else {
                    newPointData[field] = value;
                }
        
                setWorkAreas(prev => prev.map(area => 
                    area.id === areaId ? { 
                        ...area, 
                        groups: area.groups.map(g => 
                            g.id === groupId ? { 
                                ...g, 
                                points: g.points.map(p => 
                                    p.id === pointId ? { ...p, ...newPointData } : p
                                ) 
                            } : g
                        ) 
                    } : area
                ));
            }, [workAreas, utmZone, addToast, setWorkAreas]);
            
            const handleDeletePointById = (groupId, pointId) => {
                if (!selectedArea) return;
                setWorkAreas(prev => prev.map(a => 
                    a.id === selectedArea.id ? {
                        ...a, 
                        groups: a.groups.map(g => 
                            g.id === groupId ? {...g, points: g.points.filter(p => p.id !== pointId)} : g
                        )
                    } : a
                ));
                addToast('تم حذف النقطة.', 'success');
            };
            
            const handleUpdateGroupColor = (areaId, groupId, color) => {
                setWorkAreas(prev => prev.map(area => 
                    area.id === areaId ? {
                        ...area, 
                        groups: area.groups.map(g => g.id === groupId ? {...g, color} : g)
                    } : area
                ));
            };

            const handleFileLoad = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                const fileName = file.name;

                reader.onload = (e) => {
                    const content = e.target.result;
                    try {
                        if (fileName.endsWith('.hemap')) {
                            const decodedData = decodeURIComponent(escape(atob(content)));
                            const projectData = JSON.parse(decodedData);

                            if (projectData.format !== 'EngineeringMapProject' || !Array.isArray(projectData.workAreas)) {
                                throw new Error('ملف المشروع غير صالح أو تالف.');
                            }
                            
                            setWorkAreas(projectData.workAreas.map(area => ({ ...area, groups: area.groups.map(g => ({...DEFAULT_GROUP_SETTINGS, isVisible: g.isVisible !== false, ...g})) })));
                            setSelectedWorkAreaId(projectData.selectedWorkAreaId);
                            setSelectedGroupId(projectData.selectedGroupId);
                            if (projectData.utmZone) setUtmZone(projectData.utmZone);
                            addToast('تم تحميل المشروع بنجاح.', 'success');
                            
                            setTimeout(() => {
                                const loadedArea = projectData.workAreas.find(a => a.id === projectData.selectedWorkAreaId);
                                const allPoints = loadedArea?.groups.flatMap(g => g.points) || [];
                                 if (allPoints.length > 0) mapApiRef.current?.zoomToBounds(allPoints);
                            }, 200);

                        } else if (fileName.endsWith('.json')) {
                            const projectData = JSON.parse(content);
                            const dataToLoad = projectData.workAreas ? projectData.workAreas : projectData;
                            if (!Array.isArray(dataToLoad)) throw new Error('صيغة ملف JSON غير معروفة.');
                            setWorkAreas(dataToLoad.map(area => ({ ...area, groups: area.groups.map(g => ({...DEFAULT_GROUP_SETTINGS, isVisible: g.isVisible !== false, ...g})) })));
                            addToast('تم تحميل مشروع JSON بنجاح.', 'success');
                        } else {
                            if (!selectedArea) { addToast('الرجاء تحديد منطقة عمل أولاً لاستيراد النقاط.', 'error'); return; }
                            const parsedData = parseDelimitedText(content);
                            if (parsedData.error && !parsedData.data.length) { addToast(parsedData.error, 'error'); return; }
                            setModal({type: 'importPoints', props: {fileData:{...parsedData, fileName}, onClose:closeModal, onImport:handleProcessPastedPoints, utmZone:utmZone}});
                        }
                    } catch (err) {
                        console.error("File load error:", err);
                        addToast(`فشل في تحميل الملف: ${err.message}`, 'error');
                    }
                };
                reader.onerror = () => addToast('فشل في قراءة الملف.', 'error');
                reader.readAsText(file, 'UTF-8');
            };
            
            const handleProcessPastedPoints = (points) => {
                if (!selectedArea || !selectedGroup) return;
                setWorkAreas(prev => prev.map(area => 
                    area.id === selectedArea.id ? { 
                        ...area, 
                        groups: area.groups.map(g => 
                            g.id === selectedGroup.id ? { ...g, points: [...g.points, ...points] } : g
                        ), 
                        lastModifiedAt: new Date().toISOString() 
                    } : area
                ));
                addToast(`تم إضافة ${points.length} نقطة بنجاح.`, 'success');
                setTimeout(() => mapApiRef.current?.zoomToBounds(points), 100);
            };
            
            const handleOpenImportModal = () => {
                if (!selectedArea) {
                    addToast('الرجاء تحديد منطقة عمل أولاً.', 'error');
                    return;
                }
                setModal({type: 'importChoice', props: {
                    onClose: closeModal,
                    onPasteClick: () => {
                        closeModal();
                        setTimeout(() => {
                            if (coordinateSystem === 'utm') {
                                setModal({type: 'directPasteUtm', props: { onClose: closeModal, onProcessPaste: handleProcessPastedPoints, utmZone: utmZone }});
                            } else {
                                setModal({type: 'directPasteLatLng', props: { onClose: closeModal, onProcessPaste: handleProcessPastedPoints, utmZone: utmZone }});
                            }
                        }, 50);
                    },
                    onFileClick: () => {
                        closeModal();
                        fileInputRef.current.click();
                    }
                }});
            };
            
            const handleExportData = (options, fileNameFromModal) => {
                const { selectedIds, exportFormat, delimiter, fileExtension, entityType, addCsvDescription } = options;
                
                const selectedGroups = workAreas.flatMap(area => 
                    area.groups.filter(group => selectedIds[area.id] || selectedIds[`group-${group.id}`])
                );

                const pointsToExport = selectedGroups.flatMap(g => g.points)
                    .filter(p => p && p.utm && typeof p.utm.easting === 'number' && typeof p.utm.northing === 'number');

                if (pointsToExport.length === 0) {
                    addToast('لم يتم تحديد نقاط صالحة للتصدير.', 'error');
                    return null;
                }

                const safeToFixed = (num, digits = 3) => (typeof num === 'number' ? num.toFixed(digits) : '0.000');
                
                let content = '';
                
                if (exportFormat === 'csv') {
                    content = pointsToExport.map((p, index) => {
                        const base = `${safeToFixed(p.utm.easting)}${delimiter}${safeToFixed(p.utm.northing)}${delimiter}${safeToFixed(p.elevation)}`;
                        return addCsvDescription ? `${index + 1}${delimiter}${base}${delimiter}${p.description || ''}` : base;
                    }).join('\n');
                    
                    const finalFileName = `${fileNameFromModal}.${fileExtension}`;
                    const mimeType = fileExtension === 'csv' ? 'text/csv' : 'text/plain';
                    downloadFile(content, finalFileName, mimeType);
                    return null;
                } 
                else if (exportFormat === 'acad_script') {
                    if (entityType === 'pline') {
                        content = selectedGroups.map(group => 
                            "PLINE\n" + group.points.map(p => `${safeToFixed(p.utm?.easting)},${safeToFixed(p.utm?.northing)}`).join('\n')
                        ).join('\n \n');
                    } else { // points
                        content = pointsToExport.map(p => 
                            `_POINT ${safeToFixed(p.utm?.easting)},${safeToFixed(p.utm?.northing)},${safeToFixed(p.elevation)}`
                        ).join('\n');
                    }
                    return content;
                } else if (exportFormat === 'dxf') {
                    content = generateDxfContent(selectedGroups, { entityType });
                    downloadFile(content, `${fileNameFromModal}.dxf`, 'application/dxf');
                    return null;
                }

                return null;
            };

            const generateDxfContent = (groups, options) => {
                let dxf = "0\nSECTION\n2\nENTITIES\n";
                const { entityType } = options;

                groups.forEach(group => {
                    const validPoints = group.points.filter(p => p && p.utm && typeof p.utm.easting === 'number' && typeof p.utm.northing === 'number');
                    
                    if (validPoints.length === 0) return;

                    if (entityType === 'points') {
                        validPoints.forEach(p => {
                            dxf += "0\nPOINT\n";
                            dxf += `8\n${group.name.replace(/ /g, "_")}\n`;
                            dxf += `10\n${p.utm.easting.toFixed(3)}\n`;
                            dxf += `20\n${p.utm.northing.toFixed(3)}\n`;
                            dxf += `30\n${(p.elevation ?? 0).toFixed(3)}\n`;
                        });
                    } else { // pline
                        dxf += "0\nPOLYLINE\n";
                        dxf += `8\n${group.name.replace(/ /g, "_")}\n`;
                        dxf += "66\n1\n";
                        dxf += "70\n0\n";
                        validPoints.forEach(p => {
                            dxf += "0\nVERTEX\n";
                            dxf += `8\n${group.name.replace(/ /g, "_")}\n`;
                            dxf += `10\n${p.utm.easting.toFixed(3)}\n`;
                            dxf += `20\n${p.utm.northing.toFixed(3)}\n`;
                            dxf += `30\n${(p.elevation ?? 0).toFixed(3)}\n`;
                        });
                        dxf += "0\nSEQEND\n";
                    }
                });

                dxf += "0\nENDSEC\n0\nEOF\n";
                return dxf;
            };

            const triggerGetCurrentLocation = async () => {
                if (!selectedArea) { addToast('الرجاء تحديد منطقة عمل أولاً.', 'error'); return; }
                addToast('جاري جلب موقعك الحالي...', 'info');
                const { location, error } = await getCurrentLocation();
                if (location) {
                    const newPointId = await handleAddPoint(location.lat, location.lng);
                    if (newPointId) {
                        mapApiRef.current?.zoomToPoint(location.lat, location.lng);
                        setActivePointId(newPointId);
                    }
                } else {
                    addToast(error.message, 'error', 5000);
                }
            };
            
            const handleToggleDeleteMode = () => {
                setIsDeleteMode(prev => {
                    const newMode = !prev;
                    if (newMode) addToast('وضع الحذف مفعل. انقر على أي نقطة لحذفها.', 'info', 4000);
                    else addToast('تم إلغاء تفعيل وضع الحذف.', 'info', 4000);
                    return newMode;
                });
            };

            const handleUpdateGroupSettings = (settingKey, value) => {
                if (!selectedGroupId || !selectedArea) return;
                setWorkAreas(prev => prev.map(area => ({
                    ...area,
                    groups: area.groups.map(g => {
                        if (g.id === selectedGroupId) {
                            const newSettings = { ...g, [settingKey]: value };
                            if (settingKey === 'labelContent' && !g.showLabels) {
                                newSettings.showLabels = true;
                            }
                            return newSettings;
                        }
                        return g;
                    })
                })));
            };

            const handleToggleGroupVisibility = (areaId, groupId) => {
                setWorkAreas(prev => prev.map(area => ({
                    ...area,
                    groups: area.groups.map(g => 
                        g.id === groupId ? { ...g, isVisible: !g.isVisible } : g
                    )
                })));
            };
            
            const handleSetGroupMarker = (areaId, groupId, iconKey) => {
                setWorkAreas(prev => prev.map(area => ({
                    ...area,
                    groups: area.groups.map(g => {
                        if (g.id === groupId) {
                            return {
                                ...g,
                                points: g.points.map(p => ({ ...p, markerIcon: iconKey }))
                            };
                        }
                        return g;
                    })
                })));
                addToast('تم تحديث رموز المجموعة بنجاح.', 'success');
            };

            const displaySettings = useMemo(() => {
                if(selectedGroup) return { ...DEFAULT_GROUP_SETTINGS, ...selectedGroup };
                return DEFAULT_GROUP_SETTINGS;
            }, [selectedGroup]);

            const promptAction = (title, message, inputLabel, initialValue, onConfirm) => {
                setModal({type: 'prompt', props: { title, message, inputLabel, initialValue, onConfirm, onClose: closeModal }});
            };

            const handleSaveProject = () => {
                promptAction("حفظ المشروع", "أدخل اسم الملف:", "اسم الملف", "مشروعي_الهندسي", (fileName) => {
                    if (!fileName || fileName.trim() === '') { addToast('تم إلغاء الحفظ. اسم الملف فارغ.', 'error'); return; }

                    const projectData = {
                        format: 'EngineeringMapProject', version: '1.2.0', savedAt: new Date().toISOString(),
                        workAreas: workAreas, selectedWorkAreaId: selectedWorkAreaId, selectedGroupId: selectedGroupId, utmZone: utmZone
                    };

                    const jsonString = JSON.stringify(projectData, null, 2);
                    const encodedData = btoa(unescape(encodeURIComponent(jsonString)));

                    downloadFile(encodedData, `${fileName.trim()}.hemap`, 'application/octet-stream');
                    addToast('تم حفظ المشروع بنجاح.', 'success');
                });
            };

            const handleOpenScreenshotOptions = (onConfirm) => {
                setModal({type: 'screenshotOptions', props: {
                    onClose: closeModal,
                    onConfirm: (options) => {
                        closeModal();
                        if (onConfirm) {
                           onConfirm(options);
                        }
                    }
                }});
            };

            const executeScreenshot = (options, onComplete) => {
                setScreenshotOptions(options);
                setIsTakingScreenshot(true);
                
                requestAnimationFrame(() => {
                    setTimeout(() => { 
                        const captureArea = document.getElementById('capture-area');
                        if (!captureArea || !window.html2canvas) {
                            setIsTakingScreenshot(false);
                            if(onComplete) onComplete(null);
                             addToast('فشل تهيئة أداة لقطة الشاشة.', 'error');
                            return;
                        }
        
                        const elementsToHide = [
                            document.getElementById('map-controls'),
                            document.getElementById('bottom-nav-bar'),
                            document.getElementById('desktop-tools-button-container'),
                            document.getElementById('desktop-location-button'),
                            document.getElementById('active-area-indicator')
                        ];
                        
                        elementsToHide.forEach(el => { if (el) el.style.visibility = 'hidden'; });
                        
                        html2canvas(captureArea, {
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: null,
                        }).then(canvas => {
                            if(onComplete) onComplete(canvas.toDataURL('image/png'));
                        }).catch(err => {
                            console.error("Screenshot error:", err);
                            addToast('فشل أخذ لقطة الشاشة.', 'error');
                            if(onComplete) onComplete(null);
                        }).finally(() => {
                            elementsToHide.forEach(el => { if (el) el.style.visibility = 'visible'; });
                            setIsTakingScreenshot(false);
                        });
                    }, 100);
                });
            };

            const handleGeneratePDF = async (options) => {
                const { reportTitle, selectedGroupIds } = options;

                if (!selectedGroupIds || selectedGroupIds.length === 0) {
                    addToast("الرجاء تحديد مجموعة نقاط واحدة على الأقل لإنشاء التقرير.", "error");
                    return;
                }
                if (!window.jspdf || !window.html2canvas) {
                    addToast("مكتبات إنشاء التقارير غير جاهزة، يرجى المحاولة مرة أخرى بعد لحظات.", "error");
                    return;
                }
                addToast("جاري تحضير التقرير...", "info");

                const mapImageData = await new Promise(resolve => {
                    executeScreenshot({ showPanel: true, showTimestamp: true }, resolve);
                });

                if (!mapImageData) {
                    addToast("فشل التقاط صورة الخريطة للتقرير.", "error");
                    return;
                }

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                
                doc.setFont('Helvetica');
                
                let yPos = 20;
                
                // --- Header ---
                doc.setFontSize(22);
                doc.text(reportTitle || "Technical Report", doc.internal.pageSize.getWidth() / 2, yPos, { align: 'center' });
                yPos += 15;
                
                // --- Map Image ---
                const imgProps = doc.getImageProperties(mapImageData);
                const pdfWidth = doc.internal.pageSize.getWidth();
                const margin = 15;
                const imgWidth = pdfWidth - margin * 2;
                const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
                if (yPos + imgHeight > doc.internal.pageSize.getHeight() - 30) {
                    doc.addPage();
                    yPos = 20;
                }
                doc.addImage(mapImageData, 'PNG', margin, yPos, imgWidth, imgHeight);
                yPos += imgHeight + 10;

                // --- Points Table ---
                const pointsToExport = selectedArea.groups
                    .filter(g => selectedGroupIds.includes(g.id))
                    .flatMap(g => g.points);

                let tableHead;
                let tableBody;

                if (coordinateSystem === 'utm') {
                    tableHead = [['#', 'Easting (X)', 'Northing (Y)', 'Elevation (Z)', 'Description']];
                    tableBody = pointsToExport.map((p, i) => [
                        i + 1,
                        p.utm?.easting?.toFixed(3) || 'N/A',
                        p.utm?.northing?.toFixed(3) || 'N/A',
                        (p.elevation ?? 0).toFixed(3),
                        p.description || '-',
                    ]);
                } else { // latlng
                    tableHead = [['#', 'Latitude', 'Longitude', 'Elevation (Z)', 'Description']];
                    tableBody = pointsToExport.map((p, i) => [
                        i + 1,
                        p.lat?.toFixed(8) || 'N/A',
                        p.lng?.toFixed(8) || 'N/A',
                        (p.elevation ?? 0).toFixed(3),
                        p.description || '-',
                    ]);
                }

                doc.autoTable({
                    startY: yPos,
                    head: tableHead,
                    body: tableBody,
                    theme: 'grid',
                    headStyles: { font: 'Helvetica', halign: 'center', fillColor: [41, 128, 185] },
                    bodyStyles: { font: 'Helvetica', halign: 'center' },
                    columnStyles: {
                        4: { halign: 'left' }, // Description
                    },
                    didDrawPage: (data) => {
                        // Footer
                        const pageCount = doc.internal.getNumberOfPages();
                        doc.setFontSize(10);
                        doc.text(`Page ${data.pageNumber} of ${pageCount}`, data.settings.margin.left, doc.internal.pageSize.height - 10);
                        doc.text(new Date().toLocaleDateString('en-CA'), doc.internal.pageSize.width - data.settings.margin.right, doc.internal.pageSize.height - 10, { align: 'right' });
                    }
                });
                
                doc.save(`${reportTitle || 'Technical-Report'}.pdf`);
                addToast("تم إنشاء التقرير بنجاح.", "success");
            };

            const handleOpenMarkerPickerForPoint = (point, group) => {
                if (!point || !group || !selectedArea) return;
                setModal({type: 'markerPicker', props: {
                    onClose: closeModal,
                    onSelect: (iconKey) => {
                        handleUpdatePoint(selectedArea.id, group.id, point.id, 'markerIcon', iconKey);
                        closeModal();
                    },
                    currentIconKey: point.markerIcon || 'default',
                    previewColor: group.color
                }});
            };
            
            const handleOpenExportModal = () => {
                setModal({type: 'exportChoice', props: {
                    onClose: closeModal,
                    onExportClick: () => {
                        closeModal();
                        setTimeout(() => {
                            setModal({type: 'exportPoints', props: { workAreas, onClose: closeModal, onExport: handleExportData, initialFormat: 'csv' }});
                        }, 50);
                    },
                    onDxfClick: () => {
                        closeModal();
                        setTimeout(() => {
                            setModal({type: 'exportPoints', props: { workAreas, onClose: closeModal, onExport: handleExportData, initialFormat: 'dxf' }});
                        }, 50);
                    },
                    onSaveClick: () => {
                        closeModal();
                        handleSaveProject();
                    }
                }});
            };

            const handleOpenToolsModal = () => {
                setModal({type: 'tools'});
            };

            const handleOpenPdfOptions = () => {
                if (!selectedArea) {
                     addToast('الرجاء تحديد منطقة عمل أولاً.', 'error');
                     return;
                }
                 setModal({
                    type: 'pdfOptions', 
                    props: { 
                        onClose: closeModal, 
                        onConfirm: handleGeneratePDF, 
                        groups: selectedArea.groups,
                        selectedGroupId: selectedGroupId
                    }
                });
            };

            const renderModal = () => {
                if (!modal.type) return null;
                switch (modal.type) {
                    case 'prompt':
                    case 'confirm':
                        return <GenericModal type={modal.type} {...modal.props} />;
                    case 'markerPicker':
                        return <MarkerPickerModal {...modal.props} />;
                    case 'importChoice':
                        return <ImportChoiceModal {...modal.props} />;
                    case 'pasteChoice':
                        return <PasteChoiceModal {...modal.props} />;
                    case 'directPasteUtm':
                        return <DirectPasteUtmModal {...modal.props} />;
                    case 'directPasteLatLng':
                        return <DirectPasteLatLngModal {...modal.props} />;
                    case 'importPoints':
                        return <ImportPointsModal {...modal.props} />;
                    case 'exportChoice':
                        return <ExportChoiceModal {...modal.props} />;
                    case 'exportPoints':
                        return <ExportPointsModal {...modal.props} />;
                    case 'screenshotOptions':
                        return <ScreenshotOptionsModal {...modal.props} />;
                    case 'pdfOptions':
                         return <PdfOptionsModal {...modal.props} />;
                    case 'tools':
                         return <ToolsModal
                            settings={{...displaySettings, isDeleteMode}}
                            onClose={closeModal}
                            onUpdateSettings={handleUpdateGroupSettings}
                            onToggleDeleteMode={handleToggleDeleteMode}
                            onOpenScreenshotModal={() => handleOpenScreenshotOptions((options) => executeScreenshot(options, (dataUrl) => {
                                if(dataUrl) {
                                    const link = document.createElement('a');
                                    link.download = `خريطة-${new Date().toISOString().slice(0, 10)}.png`;
                                    link.href = dataUrl;
                                    link.click();
                                    addToast('تم حفظ لقطة الشاشة بنجاح.', 'success');
                                }
                            }))}
                            isZoomedInEnough={isZoomedInEnough}
                        />;
                    default:
                        return null;
                }
            };
            
            return (
                <div className="h-screen w-screen flex flex-col bg-slate-100 dark:bg-slate-900">
                    {renderModal()}
                    <input type="file" ref={fileInputRef} onChange={handleFileLoad} style={{ display: 'none' }} accept=".txt,.csv,.tsv,.json,.hemap" />
                    <Header onToggleFullScreen={() => setIsMapFullScreen(f => !f)} isFullScreen={isMapFullScreen} onToggleSidebar={() => setIsSidebarOpen(true)} />
                    <div className="flex flex-grow min-h-0"> 
                        <div className={`${isMapFullScreen ? 'hidden' : ''} lg:block`}>
                            <Sidebar 
                                isOpen={isSidebarOpen}
                                onClose={() => setIsSidebarOpen(false)}
                                workAreas={workAreas} 
                                selectedAreaId={selectedWorkAreaId}
                                selectedGroupId={selectedGroupId}
                                onSelectArea={handleSelectArea}
                                onSelectGroup={setSelectedGroupId}
                                onAddNewArea={handleAddNewArea}
                                onRenameArea={handleRenameArea}
                                onDeleteArea={handleDeleteArea}
                                onAddNewGroup={handleAddNewGroup}
                                onRenameGroup={handleRenameGroup}
                                onDeleteGroup={handleDeleteGroup}
                                onZoomToGroup={(areaId, groupId) => {
                                    const group = workAreas.find(a => a.id === areaId)?.groups.find(g => g.id === groupId);
                                    if (group && group.points.length > 0) {
                                        mapApiRef.current?.zoomToBounds(group.points);
                                    } else if (group) {
                                        addToast(`مجموعة "${group.name}" فارغة، لا يمكن التقريب.`, 'info');
                                    }
                                }}
                                onUpdateGroupColor={handleUpdateGroupColor}
                                onOpenExportModal={handleOpenExportModal}
                                onOpenImportModal={handleOpenImportModal}
                                onToggleGroupVisibility={handleToggleGroupVisibility}
                                onSetGroupMarker={handleSetGroupMarker}
                                onOpenPdfOptions={handleOpenPdfOptions}
                                setModal={setModal}
                                closeModal={closeModal}
                            />
                        </div>
                        
                        <main className="flex-grow flex flex-col relative overflow-hidden">
                            <div className={`flex-shrink-0 relative transition-all duration-300 rounded-lg overflow-hidden ${isMapFullScreen ? 'h-full' : `h-full lg:h-[${isDesktopTableExpanded ? '25%' : '60%'}]`}`} id="capture-area">
                                <div className="map-frame"></div>
                                <MapComponent
                                    ref={mapApiRef}
                                    selectedArea={selectedArea}
                                    selectedGroupId={selectedGroupId}
                                    utmZone={utmZone}
                                    onAddPoint={handleAddPoint}
                                    onUpdatePoint={handleUpdatePoint}
                                    onUpdateGroupSettings={handleUpdateGroupSettings}
                                    onActivateGroup={setSelectedGroupId}
                                    setActivePointId={setActivePointId}
                                    addToast={addToast}
                                    isDeleteMode={isDeleteMode}
                                    onDeletePointById={handleDeletePointById}
                                    onZoomChange={setCurrentZoom}
                                />
                                {selectedArea && (
                                    <>
                                        <MapControls onUndo={undo} onRedo={redo} canUndo={canUndo} canRedo={canRedo} />
                                        <ActiveAreaIndicator 
                                            areaName={selectedArea?.name} 
                                            groupName={selectedGroup?.name} 
                                            isTakingScreenshot={isTakingScreenshot}
                                        />
                                        <div id="desktop-tools-button-container" className="hidden lg:flex absolute bottom-4 left-1/2 -translate-x-1/2 z-10">
                                            <button 
                                                onClick={handleOpenToolsModal} 
                                                className="bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm py-2 px-4 rounded-full shadow-lg flex items-center gap-2 border dark:border-slate-700 hover:bg-white dark:hover:bg-slate-700 transition-colors"
                                            >
                                                <Icon name="sliders-horizontal" size={20} />
                                                <span className="font-semibold">الأدوات</span>
                                            </button>
                                        </div>
                                        <div id="desktop-location-button" className="hidden lg:block absolute bottom-4 left-4 z-10">
                                            <button 
                                                onClick={triggerGetCurrentLocation} 
                                                className="bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm text-slate-600 dark:text-slate-300 rounded-full p-3 shadow-lg hover:bg-white dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition"
                                                title="جلب الموقع الحالي"
                                            >
                                                <Icon name="locate-fixed" size={24} />
                                            </button>
                                        </div>
                                        <ScreenshotStamp 
                                            isVisible={isTakingScreenshot} 
                                            areaName={selectedArea?.name} 
                                            groupName={selectedGroup?.name}
                                            options={screenshotOptions}
                                        />
                                    </>
                                )}
                            </div>
                            
                            {!isMapFullScreen && (
                                <div className="hidden lg:flex flex-col flex-grow min-h-0 border-t-2 dark:border-slate-700">
                                    <div className="flex-shrink-0 p-2 flex justify-center items-center border-b dark:border-slate-700 bg-slate-100 dark:bg-slate-800/50">
                                        <button
                                            onClick={() => setIsDesktopTableExpanded(p => !p)}
                                            className="font-bold py-1 px-4 rounded-lg shadow-sm transition-all duration-300 flex items-center gap-2 bg-white dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600"
                                            title={isDesktopTableExpanded ? 'تصغير الجدول' : 'تكبير الجدول'}
                                        >
                                            <Icon name="list-ordered" size={20} />
                                            <span>إحداثيات</span>
                                            <Icon name={isDesktopTableExpanded ? 'chevrons-down-up' : 'chevrons-up-down'} size={16} />
                                        </button>
                                    </div>
                                    <div className="flex-grow overflow-auto">
                                        <PointsTable 
                                            selectedArea={selectedArea} 
                                            selectedGroupId={selectedGroupId}
                                            onUpdatePoint={handleUpdatePoint}
                                            onDeletePoint={handleDeletePointById}
                                            onActivateGroup={setSelectedGroupId}
                                            activePointId={activePointId}
                                            setActivePointId={setActivePointId}
                                            onZoomToPoint={(areaId, groupId, pointId) => {
                                                const point = workAreas.find(a=>a.id===areaId)?.groups.find(g=>g.id===groupId)?.points.find(p=>p.id===pointId);
                                                if(point) mapApiRef.current?.zoomToPoint(point.lat, point.lng);
                                            }}
                                            onOpenMarkerPicker={handleOpenMarkerPickerForPoint}
                                            setModal={setModal}
                                            closeModal={closeModal}
                                        />
                                    </div>
                                </div>
                            )}

                            <div className={`lg:hidden flex flex-col h-full bg-white dark:bg-slate-900 absolute inset-0 z-20 transition-transform duration-300 ease-out ${isTableViewActive ? 'translate-x-0' : 'translate-x-full'}`}>
                               <PointsTable 
                                    selectedArea={selectedArea} 
                                    selectedGroupId={selectedGroupId}
                                    onUpdatePoint={handleUpdatePoint}
                                    onDeletePoint={handleDeletePointById}
                                    onActivateGroup={setSelectedGroupId}
                                    activePointId={activePointId}
                                    setActivePointId={setActivePointId}
                                    onZoomToPoint={(areaId, groupId, pointId) => {
                                        const point = workAreas.find(a=>a.id===areaId)?.groups.find(g=>g.id===groupId)?.points.find(p=>p.id===pointId);
                                        if(point) {
                                            setIsTableViewActive(false);
                                            setActivePointId(point.id);
                                            setTimeout(() => mapApiRef.current?.zoomToPoint(point.lat, point.lng), 100);
                                        }
                                    }}
                                    onOpenMarkerPicker={handleOpenMarkerPickerForPoint}
                                    setModal={setModal}
                                    closeModal={closeModal}
                                />
                            </div>
                            
                            <div id="bottom-nav-bar" className="lg:hidden fixed bottom-0 left-0 right-0 h-16 bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm shadow-t-lg border-t dark:border-slate-700 flex justify-around items-center z-20">
                                <button onClick={() => setIsTableViewActive(false)} className={`flex flex-col items-center gap-1 ${!isTableViewActive ? 'text-blue-600' : 'text-slate-500'}`}>
                                    <Icon name="map" />
                                    <span className="text-xs">الخريطة</span>
                                </button>
                                <button onClick={() => setIsTableViewActive(true)} className={`flex flex-col items-center gap-1 ${isTableViewActive ? 'text-blue-600' : 'text-slate-500'}`}>
                                    <Icon name="list-ordered" />
                                    <span className="text-xs">النقاط</span>
                                </button>
                                <button onClick={triggerGetCurrentLocation} className="h-14 w-14 -mt-8 bg-blue-600 rounded-full text-white flex items-center justify-center shadow-lg"><Icon name="plus" size={28}/></button>
                                <button onClick={() => setIsSidebarOpen(true)} className="flex flex-col items-center gap-1 text-slate-500">
                                    <Icon name="folder-kanban" />
                                    <span className="text-xs">الطبقات</span>
                                </button>
                                <button onClick={() => setIsToolsSheetOpen(true)} className="flex flex-col items-center gap-1 text-slate-500">
                                    <Icon name="wrench" />
                                    <span className="text-xs">الأدوات</span>
                                </button>
                            </div>

                            {activePoint && activePointGroup && (
                                <PointDetailSheet 
                                    point={activePoint}
                                    group={activePointGroup}
                                    onClose={() => setActivePointId(null)}
                                    onUpdate={(field, value) => handleUpdatePoint(selectedArea.id, activePointGroup.id, activePoint.id, field, value)}
                                    onDelete={() => {
                                        handleDeletePointById(activePointGroup.id, activePoint.id);
                                        setActivePointId(null);
                                    }}
                                    onOpenMarkerPicker={() => handleOpenMarkerPickerForPoint(activePoint, activePointGroup)}
                                />
                            )}
                            
                            {isToolsSheetOpen && (
                                <ToolsSheet
                                    settings={{...displaySettings, isDeleteMode}}
                                    onClose={() => setIsToolsSheetOpen(false)}
                                    onUpdateSettings={handleUpdateGroupSettings}
                                    onToggleDeleteMode={handleToggleDeleteMode}
                                    onOpenScreenshotModal={() => handleOpenScreenshotOptions((options) => executeScreenshot(options, (dataUrl) => {
                                        if(dataUrl) {
                                            const link = document.createElement('a');
                                            link.download = `خريطة-${new Date().toISOString().slice(0, 10)}.png`;
                                            link.href = dataUrl;
                                            link.click();
                                            addToast('تم حفظ لقطة الشاشة بنجاح.', 'success');
                                        }
                                    }))}
                                    isZoomedInEnough={isZoomedInEnough}
                                />
                            )}
                        </main>
                    </div>
                </div>
            );
        }

        // ====================================================================
        //  FILE: src/main.js (Entry Point)
        // ====================================================================
        const container = document.getElementById('root');
        const root = createRoot(container);
        
        // هذه هي الدالة التي سيتم استدعاؤها بواسطة سكربت خرائط جوجل بعد تحميله
        window.initMap = () => {
            try {
                root.render(
                    <AppProvider>
                        <App />
                    </AppProvider>
                );
            } catch (error) {
                console.error("Fatal error during React rendering:", error);
                document.getElementById('root').innerHTML = '<div style="padding: 2rem; text-align: center; font-family: sans-serif;"><h1>An error occurred</h1><p>Could not load the application. Please check the console for details.</p></div>';
            }
        };
        
        // دالة تقوم بتحميل سكربت خرائط جوجل ديناميكياً باستخدام المفتاح من المتغير
        function loadGoogleMaps() {
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&libraries=geometry,places,elevation&callback=initMap`;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
        }

        // بدء تحميل السكربت
        loadGoogleMaps();
        
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>تطبيق الخرائط الهندسية - تطوير م. حمدي وحيد</title>
    
    <!-- BLOCK: STYLES & LIBRARIES -->
    <!-- هذا القسم يحتوي على جميع الروابط للمكتبات الخارجية والأنماط (CSS) التي يحتاجها التطبيق -->

    <!-- Google Fonts - Cairo: لاستخدام خط "كايرو" في التطبيق -->
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS CDN: مكتبة لتنسيق واجهة المستخدم بسرعة وسهولة عبر فئات CSS جاهزة -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM CDN: المكتبات الأساسية لتشغيل تطبيق React في المتصفح -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone: لتحويل كود JSX (الذي يدمج HTML مع JavaScript) إلى JavaScript عادي يفهمه المتصفح -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons CDN: مكتبة أيقونات خفيفة وسهلة الاستخدام -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Proj4js: مكتبة متخصصة في تحويل الإحداثيات بين أنظمة الإسقاط المختلفة (مثل WGS84 و UTM) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>

    <!-- html2canvas: مكتبة لأخذ لقطات شاشة (screenshot) لعناصر HTML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- Google Maps API: واجهة برمجة تطبيقات خرائط جوجل. لاحظ أنه يجب استبدال "YOUR_API_KEY" بمفتاحك الخاص -->
    <!-- Libraries: geometry (للحسابات الهندسية), places (للأماكن), elevation (للحصول على المناسيب) -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAKXVuJsf0vANjBtlUIWcPj-wNWPkOc-S4&libraries=geometry,places,elevation&callback=initMap"></script>

    <style>
        /* أنماط CSS مخصصة لتكملة Tailwind CSS */
        body { font-family: 'Cairo', sans-serif; overscroll-behavior: none; }
        .dark-mode { background-color: #020617; color: #e2e8f0; }
        .dark-mode body { background-color: #020617; }

        /* أنماط النافذة المنبثقة (Modal) */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); animation: fade-in 0.3s ease-out forwards; }
        .modal-content { background-color: white; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto; animation: slide-in-down 0.3s ease-out forwards; transform-origin: center; }
        .dark-mode .modal-content { background-color: #1e293b; }
        
        /* أنماط الأزرار الرئيسية والثانوية */
        .button-primary { background-color: #2563eb; color: white; padding: 0.5rem 1.25rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); }
        .button-primary:hover { background-color: #1d4ed8; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); transform: translateY(-1px); }
        .button-secondary { background-color: #64748b; color: white; padding: 0.5rem 1.25rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s; }
        .button-secondary:hover { background-color: #475569; transform: translateY(-1px); }

        /* أنماط أزرار الأيقونات */
        .icon-button { background: transparent; border: none; cursor: pointer; padding: 0.5rem; border-radius: 9999px; transition: background-color 0.2s, transform 0.2s; line-height: 1; display: flex; align-items: center; justify-content: center; }
        .icon-button:hover { background-color: rgba(0,0,0,0.1); transform: scale(1.1); }
        .dark-mode .icon-button:hover { background-color: rgba(255,255,255,0.1); }
        .icon-button.active { background-color: #2563eb; color: white; }
        .icon-button.danger.active { background-color: #ef4444; color: white; }
        .icon-button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; background-color: transparent !important; }

        /* أنماط شريط التمرير (Scrollbar) */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        .dark-mode ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #a8a29e; border-radius: 4px; }
        .dark-mode ::-webkit-scrollbar-thumb { background: #475569; }
        
        /* تأثيرات الحركة (Animations) */
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slide-in-down { from { opacity: 0; transform: translateY(-20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }

        /* أنماط الإشعارات (Toasts) */
        .toast-container { position: fixed; top: 1rem; left: 1rem; z-index: 1001; display: flex; flex-direction: column; gap: 0.5rem; }
        .toast { background-color: white; color: #333; padding: 0.75rem 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: space-between; min-width: 250px; animation: slide-in-right 0.3s ease-out forwards, fade-out 0.5s ease-in 2.5s forwards; }
        .dark-mode .toast { background-color: #1e293b; color: #e2e8f0; }
        .toast.success { border-right: 4px solid #10b981; }
        .toast.error { border-right: 4px solid #ef4444; }
        .toast.info { border-right: 4px solid #3b82f6; }
        .toast-close-button { background: none; border: none; color: #666; cursor: pointer; font-size: 1.2rem; margin-right: -0.5rem; }
        .dark-mode .toast-close-button { color: #ccc; }

        @keyframes slide-in-right { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes fade-out { from { opacity: 1; } to { opacity: 0; } }
        
        /* أنماط منتقي الألوان (Color Picker) */
        .color-picker-label { position: relative; display: inline-block; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; border: 2px solid white; box-shadow: 0 0 0 1px rgba(0,0,0,0.2); transition: transform 0.2s; }
        .color-picker-label:hover { transform: scale(1.2); }
        .color-picker-label input[type="color"] { position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
        
        /* أنماط القائمة المنسدلة المخصصة (Custom Select) */
        .custom-select { -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); background-position: left 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em; padding-left: 2.5rem; }
        .dark-mode .custom-select { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); }
    </style>
</head>
<body>
    <!-- هذا هو العنصر الجذر الذي سيتم عرض تطبيق React بداخله -->
    <div id="root"></div>

    <!-- هذا الوسم يخبر Babel بتحويل كل ما بداخله من JSX إلى JavaScript -->
    <script type="text/babel">
        // ====================================================================
        //  BLOCK: IMPORTS & SETUP
        //  هنا يتم استيراد الوظائف الأساسية من مكتبة React و ReactDOM
        // ====================================================================
        const { useState, useEffect, useRef, useCallback, useMemo, createContext, useContext, forwardRef, useImperativeHandle } = React;
        const { createRoot } = ReactDOM;

        // ====================================================================
        //  FILE: src/constants.js
        //  هذا الملف يحتوي على الثوابت التي تستخدم في جميع أنحاء التطبيق
        // ====================================================================
        const Maps_API_KEY = 'AIzaSyAKXVuJsf0vANjBtlUIWcPj-wNWPkOc-S4'; // مفتاح API لخرائط جوجل
        const DEFAULT_UTM_ZONE = 35; // منطقة UTM الافتراضية
        const SNAP_TOLERANCE_METERS = 10; // مسافة الالتقاط (Snap) بالـمتر
        const MAX_ZOOM_FOR_SNAP = 21; // أقصى مستوى تقريب (Zoom) يتم فيه تفعيل الالتقاط
        const LABEL_VISIBILITY_ZOOM_THRESHOLD = 17; // مستوى التقريب الذي تبدأ عنده التسميات (Labels) بالظهور
        const MARKER_VISIBILITY_ZOOM_THRESHOLD = 15;
        const DISTANCE_LABEL_VISIBILITY_ZOOM_THRESHOLD = 16;
        const AREA_LABEL_VISIBILITY_ZOOM_THRESHOLD = 14;
        const POINT_GROUP_COLORS = ['#3b82f6', '#22c55e', '#f97316', '#8b5cf6', '#ef4444', '#ec4899', '#14b8a6', '#6b7280']; // مصفوفة الألوان الافتراضية لمجموعات النقاط
        
        const DEFAULT_GROUP_SETTINGS = {
            showPolylines: true,
            showElevations: false,
            showLabels: false,
            labelContent: 'number',
            isMeasuring: false,
            isAreaMeasuring: false,
            snapEnabled: false,
            isVisible: true,
        };
        
        const MARKER_ICONS = {
            // Basic Shapes
            default: { type: 'default', label: 'دائرة', path: 'M 0, 0 m -10, 0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0', scale: 0.8, strokeWeight: 2.5 },
            square: { type: 'custom', label: 'مربع', path: 'M -8 -8 L 8 -8 L 8 8 L -8 8 Z', anchor: { x: 0, y: 0 }, scale: 1.2, strokeWeight: 2.5 },
            triangle: { type: 'custom', label: 'مثلث', path: 'M 0 -10 L 11.5 8 L -11.5 8 Z', anchor: { x: 0, y: 0 }, scale: 1.1, strokeWeight: 2.5 },
            cross: { type: 'custom', label: 'تقاطع (+)', path: 'M -10,0 L 10,0 M 0,-10 L 0,10', scale: 1.2, strokeWeight: 3 },
            x_cross: { type: 'custom', label: 'اكس (X)', path: 'M -9,-9 L 9,9 M 9,-9 L -9,9', scale: 1.2, strokeWeight: 3 },

            // Surveying Symbols
            benchmark: { type: 'custom', label: 'روبير', path: 'M 0 -12 L 12 6 L -12 6 Z M -12 6 L 12 6', anchor: { x: 0, y: 0 }, scale: 1, strokeWeight: 2.5 }, // Triangle with base
            station: { type: 'custom', label: 'نقطة محطة', path: 'M 0,0 m -10,0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0 M 0,-12 L 0,12 M -12,0 L 12,0', anchor: { x: 0, y: 0 }, scale: 1, strokeWeight: 2 }, // Circle with crosshairs
            control_point: { type: 'custom', label: 'نقطة تحكم', path: 'M -10 -10 L 10 -10 L 10 10 L -10 10 Z M 0,0 m -3,0 a 3,3 0 1,0 6,0 a 3,3 0 1,0 -6,0', anchor: { x: 0, y: 0 }, scale: 1.1, strokeWeight: 2.5 }, // Square with dot

            // Utility Symbols
            manhole: { type: 'custom', label: 'مانهول', path: 'M 0,0 m -12,0 a 12,12 0 1,0 24,0 a 12,12 0 1,0 -24,0 M 0,0 m -8,0 a 8,8 0 1,0 16,0 a 8,8 0 1,0 -16,0', anchor: { x: 0, y: 0 }, scale: 0.9, strokeWeight: 2 }, // Concentric circles
            valve: { type: 'custom', label: 'صمام', path: 'M -8,-8 L 8,8 M 8,-8 L -8,8', anchor: { x: 0, y: 0 }, scale: 1.2, strokeWeight: 4 }, // Bold X
            hydrant: { type: 'custom', label: 'حنفية حريق', path: 'M 0,0 m -8,0 a 8,8 0 1,0 16,0 a 8,8 0 1,0 -16,0 M -12, -4 L -12, 4 L -8,0 z M 12,-4 L 12,4 L 8,0 z', anchor: { x: 0, y: 0 }, scale: 1, strokeWeight: 2.5 }, // Circle with side triangles
            pole: { type: 'custom', label: 'عمود', path: 'M 0, 0 m -8, 0 a 8,8 0 1,0 16,0 a 8,8 0 1,0 -16,0 M 0,0 l 0, -12', anchor: { x: 0, y: 0 }, scale: 1, strokeWeight: 2 }, // Circle with line on top
            
            // Natural Features
            tree: { type: 'custom', label: 'شجرة', path: 'M 0 -5 Q 5 -15 10 -5 T 0 5 Q -5 -5 -10 -5 T 0 -5 Z M 0 5 L 0 15', anchor: { x: 0, y: 15 }, scale: 1, strokeWeight: 2 },
        };


        // ====================================================================
        //  FILE: src/utils.js
        //  هذا الملف يحتوي على الدوال المساعدة التي تستخدم في مهام متكررة
        // ====================================================================
        
        // دالة لإنشاء معرف فريد (unique ID)
        const generateUniqueId = () => Math.random().toString(36).substring(2, 9);
        
        // تعريف أنظمة الإسقاط UTM باستخدام مكتبة Proj4js
        if (window.proj4) {
            proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs"); // نظام الإحداثيات الجغرافي العالمي
            for (let i = 30; i <= 40; i++) {
                proj4.defs(`EPSG:326${i}`, `+proj=utm +zone=${i} +datum=WGS84 +units=m +no_defs`); // تعريف مناطق UTM من 30 إلى 40
            }
        }

        // دالة لتحويل الإحداثيات من خطوط الطول والعرض (Lat/Lng) إلى UTM
        const convertLatLngToUtm = (lat, lng, zone) => {
            try {
                const utmProjection = `EPSG:326${zone}`;
                if (!window.proj4.defs[utmProjection]) return null;
                const [easting, northing] = window.proj4("EPSG:4326", utmProjection, [lng, lat]);
                return { easting, northing, zone, hemisphere: lat >= 0 ? 'N' : 'S' };
            } catch (error) { console.error("Conversion error:", error); return null; }
        };

        // دالة لتحويل الإحداثيات من UTM إلى خطوط الطول والعرض (Lat/Lng)
        const convertUtmToLatLng = (easting, northing, zone) => {
            try {
                const utmProjection = `EPSG:326${zone}`;
                if (!window.proj4.defs[utmProjection]) return null;
                const [lng, lat] = window.proj4(utmProjection, "EPSG:4326", [easting, northing]);
                return { lat, lng };
            } catch (error) { console.error("Conversion error:", error); return null; }
        };
        
        // حساب الإحداثيات الأولية لمركز الخريطة
        const initialCoords = convertUtmToLatLng(765898.785, 3449300.220, DEFAULT_UTM_ZONE);
        const DEFAULT_MAP_CENTER_LAT = initialCoords ? initialCoords.lat : 31.20;
        const DEFAULT_MAP_CENTER_LNG = initialCoords ? initialCoords.lng : 29.91;
        const DEFAULT_MAP_ZOOM = 20;

        // دالة لجلب المنسوب (Elevation) من خرائط جوجل لنقطة معينة (مع محاولة إعادة الطلب في حالة الفشل)
        const getElevation = async (latLng, retries = 3, delay = 1000) => {
            if (!window.google || !window.google.maps || !window.google.maps.ElevationService) {
                console.warn("Google Maps Elevation Service not available.");
                return { elevation: null, status: 'NO_SERVICE' };
            }
            const elevationService = new window.google.maps.ElevationService();
            let lastStatus = '';

            for (let i = 0; i < retries; i++) {
                const result = await new Promise(resolve => {
                    elevationService.getElevationForLocations({ 'locations': [new window.google.maps.LatLng(latLng.lat, latLng.lng)] }, (results, status) => {
                        lastStatus = status;
                        if (status === 'OK' && results && results[0]) {
                            resolve({ success: true, elevation: results[0].elevation });
                        } else {
                            console.warn(`Elevation service attempt ${i + 1} failed with status: ${status}`);
                            resolve({ success: false });
                        }
                    });
                });
                if (result.success) return { elevation: result.elevation, status: 'OK' };
                if (lastStatus !== 'UNKNOWN_ERROR' && lastStatus !== 'OVER_QUERY_LIMIT') {
                    break; 
                }
                if (i < retries - 1) await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
            }
            console.warn(`Elevation service failed after all retries with final status: ${lastStatus}`);
            return { elevation: null, status: lastStatus };
        };

        // دالة لجلب الموقع الجغرافي الحالي للمستخدم من المتصفح
        const getCurrentLocation = () => {
            return new Promise(resolve => {
                if (!navigator.geolocation) {
                    resolve({ location: null, error: { message: "المتصفح لا يدعم تحديد الموقع." } });
                    return;
                }
                navigator.geolocation.getCurrentPosition(
                    pos => resolve({ location: { lat: pos.coords.latitude, lng: pos.coords.longitude }, error: null }),
                    err => {
                        let message = 'تعذر جلب الموقع الحالي.';
                        if (err.code === err.PERMISSION_DENIED) {
                            message = err.message.includes('policy') ? 'تم تعطيل تحديد الموقع بواسطة سياسة الأمان.' : 'تم رفض إذن تحديد الموقع.';
                        }
                        resolve({ location: null, error: { message } });
                    },
                    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                );
            });
        };

        // دالة لتحليل نص يحتوي على بيانات مفصولة (مثل CSV)
        const parseDelimitedText = (text) => {
            if (!text || typeof text !== 'string') return { data: [], error: "المحتوى فارغ أو غير صالح." };
            const lines = text.trim().split(/\r?\n/).filter(line => line.trim() !== '');
            if (lines.length === 0) return { data: [], error: "الملف فارغ." };
            
            // محاولة اكتشاف الفاصل المستخدم تلقائياً
            const delimiters = [',', '\t', ';', ' '];
            let bestDelimiter = ',';
            let maxCols = 0;
            for (const d of delimiters) {
                const cols = lines[0].split(d).length;
                if (cols > maxCols) {
                    maxCols = cols;
                    bestDelimiter = d;
                }
            }

            const data = lines.map(line => line.split(bestDelimiter).map(cell => cell.trim()));
            
            if (data.some(row => row.length !== data[0].length)) {
                 return { data, error: "بعض الصفوف لا تتطابق مع عدد الأعمدة." };
            }
            
            // محاولة اكتشاف هل يحتوي الملف على ترويسة (Header)
            let hasHeader = false;
            const firstRow = data[0];
            if (firstRow) {
                const isNumericRow = firstRow.every(cell => cell.trim() === '' || (!isNaN(parseFloat(cell)) && isFinite(cell)));
                if (!isNumericRow) {
                    hasHeader = true;
                }
            }

            return { data, error: null, hasHeader };
        };

        // دالة لتنزيل محتوى كنص في ملف
        const downloadFile = (content, fileName, mimeType) => {
            const blob = new Blob([content], { type: mimeType });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };

        // ====================================================================
        //  FILE: src/hooks/useHistoryState.js
        //  هذا هوك (Hook) مخصص لإدارة حالة التطبيق مع إضافة إمكانية التراجع (Undo) والإعادة (Redo)
        // ====================================================================
        const useHistoryState = (initialState) => {
            const historyRef = useRef({ past: [], present: initialState, future: [] });
            const [, forceUpdate] = useState({}); // مجرد دالة لإجبار إعادة العرض

            // دالة لتحديث الحالة الحالية وإضافتها إلى سجل التغييرات
            const setState = useCallback((action) => {
                const { past, present } = historyRef.current;
                const newPresent = typeof action === 'function' ? action(present) : action;
                
                if (JSON.stringify(present) === JSON.stringify(newPresent)) return; // لا تقم بأي شيء إذا لم تتغير الحالة

                historyRef.current = {
                    past: [...past, present],
                    present: newPresent,
                    future: []
                };
                forceUpdate({});
            }, []);

            // دالة التراجع
            const undo = useCallback(() => {
                const { past, present, future } = historyRef.current;
                if (past.length === 0) return;
                const previous = past[past.length - 1];
                const newPast = past.slice(0, past.length - 1);
                historyRef.current = {
                    past: newPast,
                    present: previous,
                    future: [present, ...future]
                };
                forceUpdate({});
            }, []);

            // دالة الإعادة
            const redo = useCallback(() => {
                const { past, present, future } = historyRef.current;
                if (future.length === 0) return;
                const next = future[0];
                const newFuture = future.slice(1);
                historyRef.current = {
                    past: [...past, present],
                    present: next,
                    future: newFuture
                };
                forceUpdate({});
            }, []);

            return [
                historyRef.current.present, // الحالة الحالية
                setState, // دالة تحديث الحالة
                undo, // دالة التراجع
                redo, // دالة الإعادة
                historyRef.current.past.length > 0, // هل يمكن التراجع؟
                historyRef.current.future.length > 0 // هل يمكن الإعادة؟
            ];
        };


        // ====================================================================
        //  FILE: src/contexts/AppContext.js
        //  هذا الملف يوفر "سياق" (Context) لمشاركة الحالة العامة بين المكونات المختلفة
        //  مثل (الوضع الداكن، منطقة UTM، الإشعارات، النوافذ المنبثقة)
        // ====================================================================
        const AppContext = createContext();
        const AppProvider = ({ children }) => {
            const [darkMode, setDarkMode] = useState(false);
            const [utmZone, setUtmZone] = useState(DEFAULT_UTM_ZONE);
            const [toasts, setToasts] = useState([]);
            const [modal, setModal] = useState(null);

            useEffect(() => { document.documentElement.classList.toggle('dark-mode', darkMode); }, [darkMode]);

            const addToast = useCallback((message, type = 'info', duration = 3000) => {
                const id = generateUniqueId();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), duration);
            }, []);
            
            const closeModal = useCallback(() => setModal(null), []);

            // **تصحيح:** إضافة `modal` إلى كائن السياق
            const value = useMemo(() => ({
                darkMode, setDarkMode, utmZone, setUtmZone, addToast, closeModal, setModal, modal
            }), [darkMode, utmZone, addToast, closeModal, setModal, modal]);

            return (
                <AppContext.Provider value={value}>
                    {children}
                    <div className="toast-container">
                        {toasts.map(toast => <Toast key={toast.id} {...toast} onDismiss={() => setToasts(p => p.filter(t => t.id !== toast.id))} />)}
                    </div>
                    {modal}
                </AppContext.Provider>
            );
        };
        const useAppContext = () => useContext(AppContext); // هوك مخصص للوصول السريع إلى السياق

        // ====================================================================
        //  FILE: src/components/common/Toast.js, Icon.js
        //  مكونات واجهة مستخدم عامة: الإشعارات والأيقونات
        // ====================================================================
        const Toast = ({ id, message, type, onDismiss }) => (
            <div className={`toast ${type}`}>
                <div className="flex items-center"><Icon name={type === 'success' ? 'check-circle' : 'x-circle'} className="ml-2" size={20} /><span>{message}</span></div>
                <button onClick={() => onDismiss(id)} className="toast-close-button"><Icon name="x" size={16} /></button>
            </div>
        );
        
        const Icon = ({ name, ...props }) => {
            // هذا التأثير يضمن إعادة رسم الأيقونات عند تغييرها
            useEffect(() => { window.lucide?.createIcons(); }, [name]);
            return <i data-lucide={name} {...props}></i>;
        };

        // ====================================================================
        //  FILE: src/components/layout/Header.js, Sidebar.js
        //  مكونات التخطيط الرئيسية: الشريط العلوي (Header) والشريط الجانبي (Sidebar)
        // ====================================================================
        const Header = ({ onToggleFullScreen, isFullScreen, onToggleSidebar }) => {
            const { darkMode, setDarkMode } = useAppContext();
            return (
                <header className="flex-shrink-0 bg-white shadow-md z-20 p-2 dark:bg-slate-800 dark:border-b dark:border-slate-700">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-4 space-x-reverse">
                            <button onClick={onToggleSidebar} className="icon-button lg:hidden"><Icon name="menu" /></button>
                            <Icon name="map-pin" className="text-blue-600" size={32} />
                            <div>
                                <h1 className="text-lg font-bold">تطبيق الخرائط الهندسية</h1>
                                <p className="text-xs text-slate-500 dark:text-slate-400">تطوير: م. حمدي وحيد</p>
                            </div>
                        </div>
                        <div className="flex items-center space-x-2 space-x-reverse">
                            <button onClick={() => setDarkMode(d => !d)} className="icon-button" title="الوضع الداكن/الفاتح"><Icon name={darkMode ? 'sun' : 'moon'} /></button>
                            <button onClick={onToggleFullScreen} className="icon-button" title="ملء الشاشة"><Icon name={isFullScreen ? 'minimize' : 'maximize'} /></button>
                        </div>
                    </div>
                </header>
            );
        };
        
        const Sidebar = ({ isOpen, onClose, workAreas, selectedAreaId, selectedGroupId, onSelectArea, onSelectGroup, onAddNewArea, onRenameArea, onFileLoad, onDeleteArea, onZoomToWorkArea, onGetCurrentLocation, onAddNewGroup, onRenameGroup, onDeleteGroup, onZoomToGroup, onUpdateGroupColor, onOpenExportModal, onSaveProject, onOpenDirectPasteModal, onToggleGroupVisibility, onSetGroupMarker }) => {
            const { utmZone, setUtmZone, setModal, closeModal } = useAppContext();
            const fileInputRef = useRef(null);
            const selectedArea = workAreas.find(area => area.id === selectedAreaId);
            const selectedGroup = selectedArea?.groups.find(group => group.id === selectedGroupId);

            // دوال مساعدة لفتح نوافذ منبثقة (prompt, confirm)
            const promptAction = (title, message, inputLabel, initialValue, onConfirm) => {
                setModal(<GenericModal type="prompt" title={title} message={message} inputLabel={inputLabel} initialValue={initialValue} onConfirm={onConfirm} onClose={closeModal} />);
            };
            const confirmAction = (title, message, onConfirm) => {
                setModal(<GenericModal type="confirm" title={title} message={message} onConfirm={onConfirm} onClose={closeModal} />);
            };

            // معالج حدث اختيار ملف من الجهاز
            const handleFileSelect = (event) => {
                const file = event.target.files[0];
                if (file) onFileLoad(file);
                event.target.value = null; // إعادة تعيين الحقل للسماح باختيار نفس الملف مرة أخرى
            };

            // **جديد:** دالة لفتح نافذة اختيار رمز المجموعة
            const openGroupMarkerPicker = () => {
                if (!selectedArea || !selectedGroup) return;
                setModal(
                    <MarkerPickerModal
                        onClose={closeModal}
                        onSelect={(iconKey) => {
                            onSetGroupMarker(selectedArea.id, selectedGroup.id, iconKey);
                            closeModal();
                        }}
                        currentIconKey={selectedGroup.points[0]?.markerIcon || 'default'} // Use first point's icon as a hint
                        previewColor={selectedGroup.color}
                    />
                );
            };

            const sidebarClasses = `
                fixed inset-y-0 right-0 z-40 w-72 bg-white p-4 overflow-y-auto flex-shrink-0 shadow-lg dark:bg-slate-800
                transition-transform duration-300 ease-in-out
                ${isOpen ? 'translate-x-0' : 'translate-x-full'}
                lg:relative lg:translate-x-0 lg:w-72
            `;

            return (
                <>
                    <div className={`fixed inset-0 bg-gray-900/50 z-30 lg:hidden ${isOpen ? 'block' : 'hidden'}`} onClick={onClose}></div>
                    <aside className={sidebarClasses}>
                        {/* قسم مناطق العمل */}
                        <div className="mb-6">
                            <div className="flex justify-between items-center mb-2">
                                <h2 className="text-lg font-bold">مناطق العمل</h2>
                                <button onClick={() => promptAction("منطقة عمل جديدة", "أدخل اسمًا:", "الاسم", `منطقة عمل ${workAreas.length + 1}`, name => name && onAddNewArea(name.trim()))} className="icon-button" title="إضافة منطقة عمل"><Icon name="plus-circle" className="text-blue-500" /></button>
                            </div>
                            <select id="work-area-select" value={selectedAreaId || ''} onChange={e => onSelectArea(e.target.value)} className="w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 mb-2 text-base custom-select">
                                {workAreas.map(area => (
                                    <option key={area.id} value={area.id}>{area.name} ({area.groups.length})</option>
                                ))}
                            </select>
                            {selectedArea && (
                                <div className="flex justify-between items-center mt-1">
                                    <span className="text-xs text-slate-500 dark:text-slate-400">{selectedArea.groups.length} مجموعات</span>
                                    <div className="flex items-center space-x-2 space-x-reverse">
                                        <button onClick={() => promptAction("تعديل الاسم", "أدخل الاسم الجديد:", "الاسم", selectedArea.name, newName => newName && onRenameArea(selectedArea.id, newName.trim()))} className="icon-button" title="تعديل"><Icon name="file-pen-line" size={18}/></button>
                                        <button onClick={() => confirmAction("تأكيد الحذف", `هل تريد حذف "${selectedArea.name}"؟`, () => onDeleteArea(selectedArea.id))} className="icon-button text-red-500" title="حذف"><Icon name="trash-2" size={18}/></button>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* قسم مجموعات النقاط */}
                        {selectedArea && (
                            <div className="border-t pt-4 mt-4 dark:border-slate-700">
                                <div className="flex justify-between items-center mb-2">
                                    <h2 className="text-lg font-bold">المجموعة النشطة</h2>
                                    <button onClick={() => promptAction("مجموعة جديدة", "أدخل اسمًا:", "الاسم", `مجموعة نقاط ${selectedArea.groups.length + 1}`, name => name && onAddNewGroup(selectedArea.id, name.trim()))} className="icon-button" title="إضافة مجموعة"><Icon name="folder-plus" className="text-blue-500" /></button>
                                </div>
                                <select id="point-group-select" value={selectedGroupId || ''} onChange={e => {
                                    const groupId = e.target.value;
                                    onSelectGroup(groupId);
                                    onZoomToGroup(selectedArea.id, groupId);
                                }} className="w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 mb-2 text-base custom-select">
                                    {selectedArea.groups.map(group => (
                                        <option key={group.id} value={group.id}>{group.name} ({group.points.length})</option>
                                    ))}
                                </select>
                                {selectedGroup && (
                                    <div className="flex justify-between items-center mt-1">
                                        <div className="flex items-center space-x-2 space-x-reverse">
                                            <label className="color-picker-label" style={{ backgroundColor: selectedGroup.color }}>
                                                <input type="color" value={selectedGroup.color} onChange={(e) => onUpdateGroupColor(selectedArea.id, selectedGroup.id, e.target.value)} onClick={e => e.stopPropagation()} />
                                            </label>
                                            <span className="text-xs text-slate-500 dark:text-slate-400">{selectedGroup.points.length} نقاط</span>
                                        </div>
                                        <div className="flex items-center space-x-1 space-x-reverse">
                                            {/* **تعديل:** تم نقل زر العين إلى هنا */}
                                            <button 
                                                onClick={() => onToggleGroupVisibility(selectedArea.id, selectedGroup.id)} 
                                                className={`icon-button flex-shrink-0 ${selectedGroup.isVisible ? 'active' : ''}`} 
                                                title={selectedGroup.isVisible ? 'إخفاء المجموعة' : 'إظهار المجموعة'}
                                            >
                                                <Icon name={selectedGroup.isVisible ? 'eye' : 'eye-off'} size={18} />
                                            </button>
                                            <button onClick={openGroupMarkerPicker} className="icon-button" title="تغيير رمز كل النقاط في المجموعة">
                                                <Icon name="shapes" size={18}/>
                                            </button>
                                            <button onClick={() => promptAction("تعديل اسم المجموعة", "أدخل الاسم الجديد:", "الاسم", selectedGroup.name, newName => newName && onRenameGroup(selectedArea.id, selectedGroup.id, newName.trim()))} className="icon-button" title="تعديل"><Icon name="file-pen-line" size={18}/></button>
                                            <button onClick={() => confirmAction("تأكيد حذف المجموعة", `هل تريد حذف "${selectedGroup.name}"؟`, () => onDeleteGroup(selectedArea.id, selectedGroup.id))} className="icon-button text-red-500" title="حذف"><Icon name="trash-2" size={18}/></button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                        
                        {/* قسم الأدوات والإعدادات */}
                        <div className="border-t pt-4 mt-4 dark:border-slate-700">
                            <h3 className="font-semibold mb-2">الإعدادات والأدوات</h3>
                            <label htmlFor="utm-zone-select" className="block text-sm font-medium mb-1">UTM Zone</label>
                            <select id="utm-zone-select" value={utmZone} onChange={e => setUtmZone(parseInt(e.target.value))} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 custom-select">
                                {Array.from({ length: 11 }, (_, i) => 30 + i).map(zone => <option key={zone} value={zone}>{zone}N</option>)}
                            </select>
                            <div className="mt-4 flex flex-col space-y-2">
                                <button onClick={onGetCurrentLocation} className="button-secondary flex items-center justify-center"><Icon name="crosshair" className="ml-2" size={18} />موقعي الحالي</button>
                                <button onClick={onOpenDirectPasteModal} className="button-secondary flex items-center justify-center"><Icon name="clipboard-paste" className="ml-2" size={18} />لصق احداثيات</button>
                                <input type="file" ref={fileInputRef} onChange={handleFileSelect} style={{ display: 'none' }} accept=".txt,.csv,.tsv,.json,.hemap" />
                                <button onClick={() => fileInputRef.current.click()} className="button-secondary flex items-center justify-center"><Icon name="upload" className="ml-2" size={18} />تحميل / استيراد</button>
                                <button onClick={onOpenExportModal} className="button-secondary flex items-center justify-center"><Icon name="download" className="ml-2" size={18} />تصدير نقاط</button>
                                <button onClick={onSaveProject} className="button-primary flex items-center justify-center"><Icon name="save" className="ml-2" size={18} />حفظ المشروع</button>
                            </div>
                        </div>
                    </aside>
                </>
            );
        };
        
        // مكون النافذة المنبثقة العام (Generic Modal)
        const GenericModal = ({ type, title, message, inputLabel, initialValue, onConfirm, onClose, onCancel, children, confirmText = "تأكيد" }) => {
            const [inputValue, setInputValue] = useState(initialValue || '');
            const inputRef = useRef(null);
            useEffect(() => { 
                if (type === 'prompt' && inputRef.current) {
                    inputRef.current.focus();
                    inputRef.current.select();
                } 
            }, [type]);
            const handleConfirm = () => { onConfirm(type === 'prompt' ? inputValue : undefined); onClose(); };
            const handleCancel = () => { if(onCancel) onCancel(); onClose(); };
            return (
                <div className="modal-overlay" onClick={handleCancel}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <h2 className="text-2xl font-bold mb-4 text-slate-800 dark:text-slate-100">{title}</h2>
                        {message && <p className="mb-6 text-slate-700 dark:text-slate-300">{message}</p>}
                        {type === 'prompt' && (
                            <div className="mb-6">
                                <label htmlFor="modal-input" className="block text-sm font-medium mb-1">{inputLabel}</label>
                                <input id="modal-input" ref={inputRef} type="text" value={inputValue} onChange={e => setInputValue(e.target.value)} onKeyDown={e => e.key === 'Enter' && handleConfirm()} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600" />
                            </div>
                        )}
                        {children}
                        <div className="flex justify-end space-x-3 space-x-reverse mt-6">
                            <button onClick={handleCancel} className="button-secondary">إلغاء</button>
                            <button onClick={handleConfirm} className="button-primary">{confirmText}</button>
                        </div>
                    </div>
                </div>
            );
        };

        // ====================================================================
        //  FILE: src/components/table/PointsTable.js
        //  مكون جدول عرض الإحداثيات والتحكم فيها
        // ====================================================================
        const PointsTable = ({ selectedArea, selectedGroupId, onUpdatePoint, onDeletePoint, onZoomToPoint, onActivateGroup, activePointId, setActivePointId }) => {
            const { addToast, setModal, closeModal } = useAppContext();
            const [selectedPointIds, setSelectedPointIds] = useState(new Set());
            const rowRefs = useRef({}); // لتخزين مراجع لصفوف الجدول للتحكم في التمرير
            const groupHeaderRefs = useRef({}); // **جديد:** لتخزين مراجع لترويسات المجموعات
        
            // إعادة تعيين النقاط المحددة عند تغيير منطقة العمل
            useEffect(() => {
                setSelectedPointIds(new Set());
            }, [selectedArea]);
            
            // التمرير التلقائي إلى النقطة النشطة في الجدول
            useEffect(() => {
                if (activePointId && rowRefs.current[activePointId]) {
                    rowRefs.current[activePointId].scrollIntoView({
                        behavior: 'smooth',
                        block: 'center',
                    });
                }
            }, [activePointId]);

            // **جديد:** التمرير التلقائي إلى المجموعة النشطة في الجدول
            useEffect(() => {
                if (selectedGroupId && groupHeaderRefs.current[selectedGroupId]) {
                    groupHeaderRefs.current[selectedGroupId].scrollIntoView({
                        behavior: 'smooth',
                        block: 'start',
                    });
                }
            }, [selectedGroupId]);

            // معالج لتحديد/إلغاء تحديد كل النقاط في مجموعة
            const handleSelectAll = (group, isChecked) => {
                const pointIds = group.points.map(p => p.id);
                setSelectedPointIds(prev => {
                    const newSet = new Set(prev);
                    if (isChecked) {
                        pointIds.forEach(id => newSet.add(id));
                    } else {
                        pointIds.forEach(id => newSet.delete(id));
                    }
                    return newSet;
                });
            };

            // معالج لتحديد/إلغاء تحديد نقطة واحدة
            const handleSelectPoint = (pointId) => {
                setSelectedPointIds(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(pointId)) {
                        newSet.delete(pointId);
                    } else {
                        newSet.add(pointId);
                    }
                    return newSet;
                });
            };

            // معالج لفتح نافذة اختيار رمز العلامة (Marker)
            const handleOpenMarkerPicker = (e, point, group) => {
                e.stopPropagation();
                setModal(
                    <MarkerPickerModal
                        onClose={closeModal}
                        onSelect={(iconKey) => {
                            onUpdatePoint(selectedArea.id, group.id, point.id, 'markerIcon', iconKey);
                            closeModal();
                        }}
                        currentIconKey={point.markerIcon || 'default'}
                        previewColor={group.color}
                    />
                );
            };

            // دالة لنسخ نص إلى الحافظة
            const copyToClipboard = (text, message) => {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.top = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    addToast(message, 'success');
                } catch (err) {
                    addToast('فشل النسخ إلى الحافظة.', 'error');
                }
                document.body.removeChild(textArea);
            };

            // دالة لنسخ إحداثيات UTM المحددة
            const copyUtmToClipboard = (points) => {
                if (points.length === 0) return;
                const safeToFixed = (num, digits = 3) => (typeof num === 'number' ? num.toFixed(digits) : '0.000');
                const textToCopy = points.map(p => `${safeToFixed(p.utm?.easting)},${safeToFixed(p.utm?.northing)},${safeToFixed(p.elevation)}`).join('\n');
                copyToClipboard(textToCopy, `تم نسخ ${points.length} نقطة (UTM).`);
            };
            
            // دالة لنسخ إحداثيات Lat/Lng لنقطة واحدة
            const copyLatLngToClipboard = (point) => {
                const textToCopy = `${point.lat.toFixed(8)},${point.lng.toFixed(8)}`;
                copyToClipboard(textToCopy, 'تم نسخ إحداثيات Lat/Lng.');
            };

            if (!selectedArea) return <div className="p-4 text-center text-slate-500 h-full flex items-center justify-center">الرجاء تحديد منطقة عمل.</div>;
            
            const allPoints = selectedArea.groups.flatMap(g => g.points);
            const selectedPoints = allPoints.filter(p => selectedPointIds.has(p.id));
            
            const coordInputClasses = "w-full p-1 border rounded bg-slate-50 text-slate-800 font-mono dark:bg-slate-700 dark:text-slate-200 dark:border-slate-600 focus:ring-2 focus:ring-blue-500 transition-colors";

            return (
                <div className="flex-grow p-4 overflow-auto h-full bg-white dark:bg-slate-800 flex flex-col">
                    <div className="flex justify-between items-center mb-2">
                        <h3 className="font-bold text-lg text-slate-800 dark:text-slate-100">نقاط منطقة: {selectedArea.name}</h3>
                        {selectedPoints.length > 0 && (
                            <button onClick={() => copyUtmToClipboard(selectedPoints)} className="button-primary text-sm py-1 px-3">
                                <Icon name="copy" size={14} className="inline-block ml-1" />
                                نسخ {selectedPoints.length} نقاط
                            </button>
                        )}
                    </div>
                    <div className="flex-grow overflow-y-auto">
                        {selectedArea.groups.map(group => (
                            <div key={group.id} className="mb-4" ref={el => (groupHeaderRefs.current[group.id] = el)}>
                                <div className="flex items-center mb-2 p-2 rounded-lg bg-slate-100 dark:bg-slate-800">
                                    <input type="checkbox" onChange={e => { e.stopPropagation(); handleSelectAll(group, e.target.checked); }} className="ml-2" />
                                    <span className="w-4 h-4 rounded-full ml-2" style={{ backgroundColor: group.color }}></span>
                                    <h4 className="font-semibold text-slate-700 dark:text-slate-200">{group.name}</h4>
                                </div>
                                <div className="overflow-x-auto">
                                    <table className="w-full text-sm text-left rtl:text-right">
                                        <thead className="text-xs text-gray-700 uppercase bg-slate-200 dark:bg-slate-700 dark:text-gray-400"><tr>
                                            <th className="px-1 py-2"></th>
                                            <th className="px-2 py-2">#</th>
                                            <th className="px-4 py-2">الاسم</th>
                                            <th className="px-4 py-2">Easting (X)</th>
                                            <th className="px-4 py-2">Northing (Y)</th>
                                            <th className="px-4 py-2">Elevation (Z)</th>
                                            <th className="px-4 py-2">الوصف</th>
                                            <th className="px-2 py-2 text-center">إجراءات</th>
                                        </tr></thead>
                                        <tbody>
                                        {(group.points || []).map((point, i) => (
                                            <tr 
                                                key={point.id} 
                                                ref={el => (rowRefs.current[point.id] = el)}
                                                onClick={() => {
                                                    onZoomToPoint(selectedArea.id, group.id, point.id);
                                                    onActivateGroup(group.id);
                                                    setActivePointId(point.id);
                                                }} 
                                                className={`border-b dark:border-slate-700 hover:bg-slate-100 dark:hover:bg-slate-800 cursor-pointer transition-colors duration-200 even:bg-slate-50 dark:even:bg-slate-800/50 ${point.id === activePointId ? 'bg-blue-100 dark:bg-blue-900/50 ring-2 ring-blue-500 z-10' : ''}`}
                                            >
                                                <td className="px-1 py-2"><input type="checkbox" checked={selectedPointIds.has(point.id)} onChange={() => {}} onClick={e => {e.stopPropagation(); handleSelectPoint(point.id);}} /></td>
                                                <td className="px-2 py-2 font-medium text-slate-500 dark:text-slate-400">{i + 1}</td>
                                                <td className="px-4 py-2">
                                                    <input 
                                                        type="text" 
                                                        value={point.name || ''} 
                                                        onChange={(e) => onUpdatePoint(selectedArea.id, group.id, point.id, 'name', e.target.value)}
                                                        onClick={e => e.stopPropagation()}
                                                        className="w-24 p-1 border rounded bg-transparent dark:bg-slate-700 dark:border-slate-600 focus:ring-2 focus:ring-blue-500"
                                                        placeholder={`نقطة ${i + 1}`}
                                                    />
                                                </td>
                                                <td className="px-4 py-2"><input type="number" value={point.utm?.easting?.toFixed(3) || ''} readOnly className={coordInputClasses} /></td>
                                                <td className="px-4 py-2"><input type="number" value={point.utm?.northing?.toFixed(3) || ''} readOnly className={coordInputClasses} /></td>
                                                <td className="px-4 py-2"><input type="number" value={point.elevation?.toFixed(3) || '0.000'} readOnly className={coordInputClasses} /></td>
                                                <td className="px-4 py-2">
                                                    <input 
                                                        type="text" 
                                                        value={point.description || ''} 
                                                        onChange={(e) => onUpdatePoint(selectedArea.id, group.id, point.id, 'description', e.target.value)}
                                                        onClick={e => e.stopPropagation()}
                                                        className="w-full p-1 border rounded bg-transparent dark:bg-slate-700 dark:border-slate-600 focus:ring-2 focus:ring-blue-500"
                                                        placeholder="وصف..."
                                                    />
                                                </td>
                                                <td className="px-2 py-2"><div className="flex items-center justify-center space-x-1 space-x-reverse">
                                                    <button onClick={(e) => handleOpenMarkerPicker(e, point, group)} className="icon-button" title="تغيير الرمز"><Icon name="map-pin" size={16}/></button>
                                                    <button onClick={(e) => { e.stopPropagation(); copyLatLngToClipboard(point); }} className="icon-button" title="نسخ Lat/Lng"><Icon name="globe-2" size={16}/></button>
                                                    <button onClick={(e) => { e.stopPropagation(); copyUtmToClipboard([point]); }} className="icon-button" title="نسخ UTM"><Icon name="copy" size={16}/></button>
                                                    <button onClick={e => {e.stopPropagation(); onDeletePoint(group.id, point.id);}} className="icon-button text-red-500" title="حذف"><Icon name="trash-2" size={16}/></button>
                                                </div></td>
                                            </tr>
                                        ))}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // ====================================================================
        //  FILE: src/components/map/CustomLabel.js
        //  مكون لإنشاء تسميات (Labels) مخصصة على الخريطة باستخدام Google Maps OverlayView
        // ====================================================================
        const CustomLabel = ({ map, position, text, styleProps }) => {
            const overlay = useRef(null);

            useEffect(() => {
                // تعريف فئة (Class) للتسمية المخصصة التي ترث من OverlayView
                class CustomLabelOverlay extends window.google.maps.OverlayView {
                    constructor(position, text, styleProps) {
                        super();
                        this.position = position;
                        this.text = text;
                        this.styleProps = styleProps;
                        this.div = null;
                    }

                    // دالة onAdd: يتم استدعاؤها عند إضافة التسمية إلى الخريطة لأول مرة
                    onAdd() {
                        const div = document.createElement('div');
                        div.style.position = 'absolute';
                        div.style.whiteSpace = 'nowrap';
                        this.div = div;
                        this.updateText();
                        this.updateStyle();
                        this.getPanes().floatPane.appendChild(this.div); // إضافة العنصر إلى طبقة floatPane
                    }

                    // دالة draw: يتم استدعاؤها عند الحاجة لإعادة رسم التسمية (عند تحريك الخريطة أو تغيير التقريب)
                    draw() {
                        const proj = this.getProjection();
                        if (!proj || !this.div) return;
                        const point = proj.fromLatLngToDivPixel(this.position); // تحويل إحداثيات LatLng إلى بكسل على الشاشة
                        if (point) {
                            this.div.style.left = point.x + 'px';
                            this.div.style.top = point.y + 'px';
                        }
                    }

                    // دالة onRemove: يتم استدعاؤها عند إزالة التسمية من الخريطة
                    onRemove() {
                        if (this.div) {
                            this.div.parentNode.removeChild(this.div);
                            this.div = null;
                        }
                    }
                    
                    // دوال مساعدة لتحديث خصائص التسمية
                    updateText(text) { if(this.div) this.div.innerHTML = text || this.text; }
                    updatePosition(position) { this.position = position; this.draw(); }
                    updateStyle(styleProps) {
                        if (!this.div) return;
                        const styles = styleProps || this.styleProps;
                        Object.assign(this.div.style, styles);
                    }
                }

                overlay.current = new CustomLabelOverlay(position, text, styleProps);
                overlay.current.setMap(map);
                
                return () => overlay.current?.setMap(null); // تنظيف: إزالة التسمية عند إزالة المكون
            }, [map]);

            // تأثيرات لتحديث التسمية عند تغيير الخصائص
            useEffect(() => { overlay.current?.updatePosition(position); }, [position]);
            useEffect(() => { overlay.current?.updateText(text); }, [text]);
            useEffect(() => { overlay.current?.updateStyle(styleProps); }, [styleProps]);

            return null; // هذا المكون لا يعرض أي شيء مباشرة في DOM الخاص بـ React
        };

        // ====================================================================
        //  FILE: src/components/map/MapToolbar.js, MapComponent.js, and new UI elements
        //  المكونات الأساسية للخريطة: شريط الأدوات، مكون الخريطة نفسه، وعناصر واجهة مستخدم إضافية
        // ====================================================================
        
        // مكون شريط الأدوات العائم على الخريطة
        const FloatingToolbar = ({ settings, onUpdateSettings, onAddPointFromCurrentLocation, isDeleteMode, onToggleDeleteMode, isZoomedInEnough, onTakeScreenshot }) => {
            const [isOpen, setIsOpen] = useState(false);
            const { showPolylines, showElevations, showLabels, labelContent, isMeasuring, isAreaMeasuring, snapEnabled } = settings;
            
            const tools = [
                { id: 'screenshot', icon: 'camera', title: 'أخذ لقطة شاشة', action: onTakeScreenshot, active: false },
                { id: 'location', icon: 'crosshair', title: 'إضافة نقطة من موقعي', action: onAddPointFromCurrentLocation, active: false },
                { id: 'measure', icon: 'ruler', title: 'قياس المسافة', action: () => onUpdateSettings('isMeasuring', !isMeasuring), active: isMeasuring },
                { id: 'area', icon: 'square', title: 'قياس المساحة', action: () => onUpdateSettings('isAreaMeasuring', !isAreaMeasuring), active: isAreaMeasuring },
                { id: 'polyline', icon: 'git-commit', title: 'إظهار/إخفاء الخطوط', action: () => onUpdateSettings('showPolylines', !showPolylines), active: showPolylines },
                { id: 'elevation', icon: 'text', title: isZoomedInEnough ? 'إظهار/إخفاء المناسيب' : 'قرّب لرؤية المناسيب', action: () => onUpdateSettings('showElevations', !showElevations), active: showElevations, disabled: !isZoomedInEnough },
                { id: 'showLabels', icon: 'hash', title: isZoomedInEnough ? 'إظهار/إخفاء التسميات' : 'قرّب لرؤية التسميات', action: () => onUpdateSettings('showLabels', !showLabels), active: showLabels, disabled: !isZoomedInEnough },
                { id: 'labelContent', icon: 'type', title: isZoomedInEnough ? 'تبديل محتوى التسمية (رقم/اسم)' : 'قرّب لتبديل التسميات', action: () => onUpdateSettings('labelContent', labelContent === 'number' ? 'name' : 'number'), active: labelContent === 'name', disabled: !isZoomedInEnough },
                { id: 'snap', icon: 'magnet', title: 'تفعيل/إلغاء الالتقاط', action: () => onUpdateSettings('snapEnabled', !snapEnabled), active: snapEnabled },
                { id: 'delete', icon: 'trash-2', title: 'حذف نقطة بالنقر', action: onToggleDeleteMode, active: isDeleteMode, danger: true },
            ];

            return (
                 <div id="floating-toolbar" className="absolute bottom-4 left-4 z-10 flex flex-row-reverse items-center gap-2">
                    <button 
                        onClick={() => setIsOpen(o => !o)} 
                        className="w-14 h-14 bg-blue-600 text-white rounded-full shadow-lg flex items-center justify-center hover:bg-blue-700 transition-all duration-300"
                    >
                        <Icon name={isOpen ? 'x' : 'layers'} className={`transition-transform duration-300 ${isOpen ? 'rotate-90' : ''}`} size={28} />
                    </button>
                    <div className={`flex flex-row-reverse items-center space-x-2 space-x-reverse transition-opacity duration-300 ${isOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
                        {tools.map((tool, index) => (
                             <div 
                                key={tool.id} 
                                className={`transition-all duration-300 ease-out ${isOpen ? 'opacity-100 translate-x-0' : 'opacity-0 -translate-x-4'}`}
                                style={{ transitionDelay: `${isOpen ? index * 40 : (tools.length - index - 1) * 20}ms` }}
                             >
                                <button onClick={tool.action} disabled={tool.disabled} className={`icon-button bg-white dark:bg-slate-700 shadow-md ${tool.active ? (tool.danger ? 'danger active' : 'active') : ''}`} title={tool.title}>
                                    <Icon name={tool.icon} />
                                </button>
                             </div>
                        ))}
                    </div>
                </div>
            );
        };
        
        // مكون أزرار التراجع والإعادة
        const HistoryControls = ({ undo, redo, canUndo, canRedo }) => (
            <div id="history-controls" className="absolute top-4 left-4 z-10 bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm p-1 rounded-full shadow-lg flex border dark:border-slate-700">
                <button onClick={undo} disabled={!canUndo} className="icon-button" title="تراجع (Ctrl+Z)"><Icon name="undo-2" /></button>
                <div className="w-px bg-slate-300 dark:bg-slate-600 my-2"></div>
                <button onClick={redo} disabled={!canRedo} className="icon-button" title="إعادة (Ctrl+Y)"><Icon name="redo-2" /></button>
            </div>
        );

        // **تعديل:** تحديث المكون لقبول خاصية جديدة وتغيير النص
        const ActiveAreaIndicator = ({ areaName, groupName, isTakingScreenshot }) => (
            <div id="active-area-indicator" className="absolute top-4 right-4 z-10 bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm p-2 px-4 rounded-lg shadow-lg border dark:border-slate-700 text-sm">
                <p><span className="font-semibold">منطقة العمل:</span> {areaName || 'غير محدد'}</p>
                <p><span className="font-semibold">{isTakingScreenshot ? 'المجموعة:' : 'المجموعة النشطة:'}</span> {groupName || 'غير محدد'}</p>
            </div>
        );

        // مكون الخريطة الرئيسي
        const MapComponent = forwardRef(({ selectedArea, utmZone, onAddPoint, onUpdatePoint, addToast, onUpdateGroupSettings, selectedGroupId, isDeleteMode, onDeletePointById, onActivateGroup, setActivePointId, onZoomChange }, ref) => {
            const { darkMode } = useAppContext();
            const mapRef = useRef(null); // مرجع لعنصر div الخاص بالخريطة
            const [map, setMap] = useState(null); // حالة لتخزين كائن الخريطة
            const [mapOverlays, setMapOverlays] = useState([]); // حالة لتخزين التسميات المخصصة
            const markersRef = useRef({}); // مرجع لتخزين العلامات (Markers)
            const polylinesRef = useRef({}); // مرجع لتخزين الخطوط (Polylines)
            const infoWindowRef = useRef(null); // مرجع لنافذة المعلومات
            const onAddPointRef = useRef(onAddPoint);
            useEffect(() => { onAddPointRef.current = onAddPoint; }, [onAddPoint]);

            // useImperativeHandle يسمح للمكون الأب باستدعاء دوال داخل هذا المكون
            useImperativeHandle(ref, () => ({
                zoomToPoint(lat, lng) { map?.setCenter({ lat, lng }); map?.setZoom(21); },
                zoomToBounds(boundsData) {
                    if (map && boundsData && boundsData.length > 0) {
                        const bounds = new window.google.maps.LatLngBounds();
                        boundsData.forEach(p => bounds.extend(new window.google.maps.LatLng(p.lat, p.lng)));
                        map.fitBounds(bounds);
                    }
                },
                resetView() {
                    map?.setCenter({ lat: DEFAULT_MAP_CENTER_LAT, lng: DEFAULT_MAP_CENTER_LNG });
                    map?.setZoom(DEFAULT_MAP_ZOOM);
                }
            }));

            // تأثير لتهيئة الخريطة عند تحميل المكون لأول مرة
            useEffect(() => {
                if (mapRef.current && !map) {
                    const mapInstance = new window.google.maps.Map(mapRef.current, { center: { lat: DEFAULT_MAP_CENTER_LAT, lng: DEFAULT_MAP_CENTER_LNG }, zoom: DEFAULT_MAP_ZOOM, mapTypeId: 'satellite', mapTypeControl: false, streetViewControl: false, fullscreenControl: false, zoomControl: true, clickableIcons: !isDeleteMode });
                    infoWindowRef.current = new window.google.maps.InfoWindow();
                    
                    // إضافة مستمع لحدث النقر على الخريطة لإضافة نقطة
                    mapInstance.addListener('click', (e) => {
                        if (isDeleteMode) {
                            addToast('وضع الحذف مفعل. انقر على نقطة لحذفها.', 'info');
                            return;
                        }
                        onAddPointRef.current(e.latLng.lat(), e.latLng.lng());
                    });
                    
                    // إضافة مستمع لحدث تغيير مستوى التقريب
                    mapInstance.addListener('zoom_changed', () => {
                        const currentZoom = mapInstance.getZoom();
                        onZoomChange(currentZoom);
                        if (selectedGroupId) {
                            const shouldBeEnabled = currentZoom < MAX_ZOOM_FOR_SNAP;
                            onUpdateGroupSettings(selectedGroupId, 'snapEnabled', shouldBeEnabled);
                        }
                    });
                    
                    setMap(mapInstance);
                }
            }, [mapRef, map, selectedGroupId, onUpdateGroupSettings]);

            // تأثير لتغيير شكل مؤشر الفأرة حسب وضع الحذف
            useEffect(() => {
                if(map) {
                    map.setOptions({ draggableCursor: isDeleteMode ? 'crosshair' : null, clickableIcons: !isDeleteMode });
                }
            }, [map, isDeleteMode]);

            // التأثير الرئيسي لرسم كل شيء على الخريطة (علامات، خطوط، تسميات)
            useEffect(() => {
                if (!map) return;
                // تنظيف الخريطة قبل إعادة الرسم
                Object.values(markersRef.current).forEach(m => m.setMap(null));
                markersRef.current = {};
                Object.values(polylinesRef.current).forEach(p => p.setMap(null));
                polylinesRef.current = {};
                
                const newOverlays = [];
                const currentZoom = map.getZoom();

                if (selectedArea) {
                    // **تعديل:** فلترة المجموعات بناءً على خاصية isVisible
                    selectedArea.groups.filter(group => group.isVisible).forEach(group => {
                        const { showPolylines, showElevations, showLabels, labelContent, isMeasuring, isAreaMeasuring } = group;
                        const path = [];
                        const canShowAnyLabel = currentZoom >= LABEL_VISIBILITY_ZOOM_THRESHOLD;

                        (group.points || []).forEach((point, index) => {
                            const latLng = new window.google.maps.LatLng(point.lat, point.lng);
                            path.push(latLng);

                            // إعداد أيقونة العلامة
                            const iconKey = point.markerIcon || 'default';
                            const iconDefinition = MARKER_ICONS[iconKey] || MARKER_ICONS['default'];
                            const markerIcon = { path: iconDefinition.path, fillColor: group.color, fillOpacity: 1, strokeWeight: iconDefinition.strokeWeight, strokeColor: '#ffffff', scale: iconDefinition.scale, anchor: iconDefinition.anchor ? new window.google.maps.Point(iconDefinition.anchor.x, iconDefinition.anchor.y) : null };

                            // إنشاء العلامة مع خاصية الرؤية المعتمدة على الزوم
                            const marker = new window.google.maps.Marker({ 
                                position: latLng, 
                                map, 
                                draggable: !isDeleteMode, 
                                title: `نقطة ${index + 1} (${group.name})`, 
                                icon: markerIcon, 
                                cursor: isDeleteMode ? 'pointer' : 'grab',
                                visible: currentZoom >= MARKER_VISIBILITY_ZOOM_THRESHOLD // **جديد:** التحكم برؤية العلامة
                            });
                            markersRef.current[point.id] = marker;
                            
                            // **تعديل:** منطق جديد لإنشاء التسميات بناءً على الزوم
                            let labelText = '';
                            if (canShowAnyLabel) {
                                let pointLabel = '';
                                let elevationLabel = '';

                                if (showLabels) {
                                    pointLabel = (labelContent === 'name') ? (point.name || `${index + 1}`) : `${index + 1}`;
                                }
                                if (showElevations && point.elevation != null) {
                                    elevationLabel = point.elevation.toFixed(2);
                                }

                                if (pointLabel && elevationLabel) {
                                    labelText = `${pointLabel} (${elevationLabel})`;
                                } else {
                                    labelText = pointLabel || elevationLabel;
                                }
                            }

                            if (labelText) {
                                newOverlays.push({ id: `point-${point.id}`, position: latLng, text: labelText, styleProps: { transform: 'translate(-50%, -50px)', background: group.color, color: 'white', padding: '4px 10px', borderRadius: '16px', fontSize: '24px', fontWeight: 'bold', border: '1px solid rgba(255,255,255,0.75)', boxShadow: '0 1px 4px rgba(0,0,0,0.4)' } });
                            }

                            // إعداد محتوى نافذة المعلومات
                            const utm = convertLatLngToUtm(point.lat, point.lng, utmZone);
                            const infoContent = `<div dir="rtl"><h4>نقطة ${index + 1} (${group.name})</h4><p>Lat: ${point.lat.toFixed(6)}</p><p>Lng: ${point.lng.toFixed(6)}</p>${utm ? `<p>Easting: ${utm.easting.toFixed(2)}</p><p>Northing: ${utm.northing.toFixed(2)}</p>` : ''}<p>Elevation: ${point.elevation != null ? point.elevation.toFixed(2) : 'N/A'}</p>${point.description ? `<p>الوصف: ${point.description}</p>` : ''}</div>`;
                            
                            // إضافة مستمع لحدث النقر على العلامة
                            marker.addListener('click', () => { 
                                onActivateGroup(group.id);
                                setActivePointId(point.id);
                                if (isDeleteMode) {
                                    onDeletePointById(group.id, point.id);
                                } else {
                                    infoWindowRef.current.setContent(infoContent); 
                                    infoWindowRef.current.open(map, marker); 
                                }
                            });
                            
                            // إضافة مستمع لحدث سحب العلامة
                            marker.addListener('dragend', (event) => {
                                const newLatLng = event.latLng;
                                let finalLat = newLatLng.lat(), finalLng = newLatLng.lng();
                                
                                // منطق الالتقاط (Snapping)
                                const allOtherPoints = selectedArea.groups.flatMap(g => g.points).filter(p => p.id !== point.id);
                                if (group.snapEnabled && allOtherPoints.length > 0) {
                                    const closestPoint = allOtherPoints.reduce((closest, current) => {
                                        const distance = window.google.maps.geometry.spherical.computeDistanceBetween(newLatLng, new window.google.maps.LatLng(current.lat, current.lng));
                                        return distance < closest.distance ? { distance, point: current } : closest;
                                    }, { distance: Infinity, point: null });

                                    if (closestPoint.distance < SNAP_TOLERANCE_METERS) {
                                        finalLat = closestPoint.point.lat;
                                        finalLng = closestPoint.point.lng;
                                        addToast('تم الالتقاط إلى نقطة قريبة.', 'info');
                                    }
                                }
                                
                                onUpdatePoint(selectedArea.id, group.id, point.id, 'latlng', { lat: finalLat, lng: finalLng });
                            });
                        });

                        // رسم الخطوط (Polylines)
                        if (showPolylines && path.length > 1) {
                            // **جديد:** تحسين بصري للخطوط عند التصغير
                            const polylineStyle = currentZoom < MARKER_VISIBILITY_ZOOM_THRESHOLD 
                                ? { strokeOpacity: 1.0, strokeWeight: 5 } // أكثر سماكة ووضوحًا عند التصغير
                                : { strokeOpacity: 0.8, strokeWeight: 3 }; // النمط العادي

                            polylinesRef.current[group.id] = new window.google.maps.Polyline({ 
                                path, 
                                map, 
                                geodesic: true, 
                                strokeColor: group.color, 
                                ...polylineStyle 
                            });
                            
                            // **تعديل:** إضافة شرط الزوم لعرض الأطوال
                            if (isMeasuring && currentZoom >= DISTANCE_LABEL_VISIBILITY_ZOOM_THRESHOLD) {
                                for (let i = 0; i < path.length - 1; i++) {
                                    const p1 = path[i], p2 = path[i+1];
                                    const distance = window.google.maps.geometry.spherical.computeDistanceBetween(p1, p2);
                                    const midpoint = window.google.maps.geometry.spherical.interpolate(p1, p2, 0.5);
                                    let distanceText;
                                    if (distance > 10000) { 
                                        distanceText = `${(distance / 1000).toFixed(2)} كم`;
                                    } else {
                                        distanceText = `${distance.toFixed(2)} م`;
                                    }
                                    newOverlays.push({ id: `dist-${group.id}-${i}`, position: midpoint, text: distanceText, styleProps: { transform: 'translate(-50%, -50%)', background: darkMode ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.8)', color: darkMode ? 'white' : 'black', padding: '4px 8px', borderRadius: '6px', fontSize: '14px', fontWeight: 'bold', border: `1px solid ${darkMode ? 'white' : 'black'}` } });
                                }
                            }
                        }
                        
                        // **تعديل:** إضافة شرط الزوم لعرض المساحة
                        if (isAreaMeasuring && path.length >= 3 && currentZoom >= AREA_LABEL_VISIBILITY_ZOOM_THRESHOLD) {
                            const area = window.google.maps.geometry.spherical.computeArea(path);
                            const bounds = new window.google.maps.LatLngBounds();
                            path.forEach(p => bounds.extend(p));
                            let areaText;
                            if (area > 400000) { 
                                areaText = `المساحة: ${(area / 1000000).toFixed(3)} كم²`;
                            } else {
                                areaText = `المساحة: ${area.toFixed(2)} م²`;
                            }
                            newOverlays.push({ id: `area-${group.id}`, position: bounds.getCenter(), text: areaText, styleProps: { transform: 'translate(-50%, -50%)', background: darkMode ? 'rgba(30,41,59,0.9)' : 'rgba(241,245,249,0.9)', color: darkMode ? '#f1f5f9' : '#1e293b', padding: '8px 12px', borderRadius: '8px', fontSize: '16px', fontWeight: 'bold', border: `2px solid ${group.color}` } });
                        }
                    });
                }
                setMapOverlays(newOverlays);
            }, [map, selectedArea, utmZone, onUpdatePoint, darkMode, addToast, isDeleteMode, onDeletePointById, onActivateGroup, setActivePointId]);

            return (
                <>
                    <div ref={mapRef} className="w-full h-full" id="map-container"></div>
                    {mapOverlays.map(overlay => <CustomLabel key={overlay.id} map={map} {...overlay} />)}
                </>
            );
        });

        // ====================================================================
        //  FILE: src/components/import/ImportExportModals.js
        //  مكونات النوافذ المنبثقة لعمليات الاستيراد والتصدير واختيار الرموز
        // ====================================================================
        
        // نافذة منبثقة لاختيار رمز العلامة (Marker)
        const MarkerPickerModal = ({ onClose, onSelect, currentIconKey, previewColor = '#6b7280' }) => {
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-2xl font-bold text-slate-800 dark:text-slate-100">اختر رمز النقطة</h2>
                            <button onClick={onClose} className="icon-button"><Icon name="x" /></button>
                        </div>
                        <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4">
                            {Object.entries(MARKER_ICONS).map(([key, iconDef]) => (
                                <div key={key}
                                    onClick={() => onSelect(key)}
                                    className={`flex flex-col items-center justify-center p-4 rounded-lg cursor-pointer transition-all duration-200 ${currentIconKey === key ? 'bg-blue-100 dark:bg-blue-800 ring-2 ring-blue-500' : 'bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600'}`}
                                >
                                    <svg width="48" height="48" viewBox="-20 -20 40 40" fill={previewColor} stroke="white" strokeWidth="1.5">
                                        <path d={iconDef.path} />
                                    </svg>
                                    <span className="mt-2 text-sm text-center">{iconDef.label}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // نافذة منبثقة للصق الإحداثيات مباشرة
        const DirectPasteModal = ({ onClose, onProcessPaste, utmZone }) => {
            const { addToast } = useAppContext();
            const [text, setText] = useState('');

            const handleProcessClick = () => {
                if (!text.trim()) {
                    addToast("الرجاء لصق الإحداثيات في المربع.", "error");
                    return;
                }

                const { data: rows, error } = parseDelimitedText(text);
                if (error) {
                    addToast(`خطأ في التحليل: ${error}`, "error");
                }
                if (!rows || rows.length === 0) {
                    addToast("لم يتم العثور على بيانات صالحة.", "error");
                    return;
                }

                const pointsToImport = rows.map(row => {
                    if (row.length < 2) return null;
                    
                    const easting = parseFloat(row[0]);
                    const northing = parseFloat(row[1]);
                    const elevation = row.length > 2 ? parseFloat(row[2]) : null;
                    const description = row.length > 3 ? row[3] : '';

                    if (isNaN(easting) || isNaN(northing)) return null;
                    
                    const latLng = convertUtmToLatLng(easting, northing, utmZone);
                    if (!latLng) return null;
                    
                    return { id: generateUniqueId(), lat: latLng.lat, lng: latLng.lng, elevation: isNaN(elevation) ? null : elevation, utm: { easting, northing, zone: utmZone }, description, markerIcon: 'default', createdAt: new Date().toISOString() };
                }).filter(Boolean);

                if (pointsToImport.length === 0) {
                    addToast("لم يتم العثور على نقاط صالحة للاستيراد من النص.", "error");
                    return;
                }

                onProcessPaste(pointsToImport);
                onClose();
            };

            return (
                <GenericModal 
                    title="لصق مباشر للإحداثيات" 
                    onClose={onClose} 
                    onConfirm={handleProcessClick} 
                    confirmText="معالجة وتوقيع"
                >
                    <p className="mb-4 text-slate-600 dark:text-slate-300">
                        قم بلصق الإحداثيات في المربع أدناه. يجب أن تكون بتنسيق (Easting, Northing, [Elevation], [Description]) مفصولة بفاصلة أو مسافة أو تاب.
                    </p>
                    <textarea
                        value={text}
                        onChange={e => setText(e.target.value)}
                        className="w-full h-48 p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 font-mono text-sm"
                        placeholder="766640.84, 3449894.71, 12.34, Point1&#10;766650.12 3449900.56 12.50 BlockA&#10;..."
                    />
                </GenericModal>
            );
        };
        
        // نافذة منبثقة لاستيراد النقاط من ملف
        const ImportPointsModal = ({ fileData, onClose, onImport, utmZone }) => {
            const { addToast } = useAppContext();
            const [mappings, setMappings] = useState({ easting: '0', northing: '1', elevation: '-1', description: '-1' });
            const [groupName, setGroupName] = useState(fileData.fileName ? `استيراد - ${fileData.fileName}` : 'مجموعة مستوردة');
            const [ignoreHeader, setIgnoreHeader] = useState(fileData.hasHeader);

            const { headers, dataRows } = useMemo(() => {
                const rawData = fileData.data || [];
                if (rawData.length === 0) return { headers: [], dataRows: [] };
                
                const headerRow = ignoreHeader ? rawData[0] : rawData[0].map((_, i) => `العمود ${i + 1}`);
                const dataContent = ignoreHeader ? rawData.slice(1) : rawData;
                
                return { headers: headerRow, dataRows: dataContent };
            }, [fileData.data, ignoreHeader]);

            // تأثير لاكتشاف أعمدة الإحداثيات تلقائياً من الترويسة
            useEffect(() => {
                if (ignoreHeader && headers.length > 0) {
                    const lowerCaseHeaders = headers.map(h => h.toLowerCase());
                    const eastingIndex = lowerCaseHeaders.findIndex(h => h.includes('east') || h === 'x');
                    const northingIndex = lowerCaseHeaders.findIndex(h => h.includes('north') || h === 'y');
                    const elevationIndex = lowerCaseHeaders.findIndex(h => h.includes('elev') || h.includes('z'));
                    const descriptionIndex = lowerCaseHeaders.findIndex(h => h.includes('desc') || h.includes('code'));
                    
                    setMappings({
                        easting: eastingIndex !== -1 ? `${eastingIndex}` : '0',
                        northing: northingIndex !== -1 ? `${northingIndex}` : '1',
                        elevation: elevationIndex !== -1 ? `${elevationIndex}` : '-1',
                        description: descriptionIndex !== -1 ? `${descriptionIndex}` : '-1',
                    });
                }
            }, [headers, ignoreHeader]);

            const handleImportClick = () => {
                if (!mappings.easting || !mappings.northing) { addToast("الرجاء تحديد أعمدة Easting و Northing.", "error"); return; }
                if (!groupName.trim()) { addToast("الرجاء إدخال اسم للمجموعة.", "error"); return; }
                
                const pointsToImport = dataRows.map(row => {
                    const easting = parseFloat(row[parseInt(mappings.easting)]);
                    const northing = parseFloat(row[parseInt(mappings.northing)]);
                    const elevation = mappings.elevation !== '-1' ? parseFloat(row[parseInt(mappings.elevation)]) : null;
                    const description = mappings.description !== '-1' ? row[parseInt(mappings.description)] : '';
                    if (isNaN(easting) || isNaN(northing)) return null;
                    const latLng = convertUtmToLatLng(easting, northing, utmZone);
                    if (!latLng) return null;
                    return { id: generateUniqueId(), lat: latLng.lat, lng: latLng.lng, elevation: isNaN(elevation) ? null : elevation, utm: { easting, northing, zone: utmZone }, description, markerIcon: 'default', createdAt: new Date().toISOString() };
                }).filter(Boolean);

                if (pointsToImport.length === 0) { addToast("لم يتم العثور على نقاط صالحة للاستيراد.", "error"); return; }
                onImport(groupName.trim(), pointsToImport);
                onClose();
            };

            const getColumnPreview = (colIndex) => {
                if (colIndex === '-1' || !dataRows || dataRows.length === 0) return "لا يوجد";
                return dataRows.slice(0, 3).map(row => row[colIndex]).join(', ') + (dataRows.length > 3 ? ', ...' : '');
            };

            return (
                <GenericModal title="استيراد نقاط من ملف" onClose={onClose} onConfirm={handleImportClick} confirmText="استيراد">
                    <div className="mb-4">
                        <label className="block text-sm font-medium mb-1">اسم المجموعة الجديدة</label>
                        <input type="text" value={groupName} onChange={e => setGroupName(e.target.value)} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600" />
                    </div>
                    <div className="flex items-center mb-4">
                        <input type="checkbox" id="ignore-header" checked={ignoreHeader} onChange={e => setIgnoreHeader(e.target.checked)} className="ml-2" />
                        <label htmlFor="ignore-header">الصف الأول يحتوي على ترويسة (أسماء الأعمدة)</label>
                    </div>
                    <h3 className="text-lg font-semibold mb-2">ربط الأعمدة</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label className="block text-sm font-medium mb-1">Easting (X)</label>
                            <select value={mappings.easting} onChange={e => setMappings(m => ({...m, easting: e.target.value}))} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                {headers.map((h, i) => <option key={i} value={i}>{h}</option>)}
                            </select>
                            <p className="text-xs text-slate-500 mt-1">معاينة: {getColumnPreview(mappings.easting)}</p>
                        </div>
                        <div>
                            <label className="block text-sm font-medium mb-1">Northing (Y)</label>
                            <select value={mappings.northing} onChange={e => setMappings(m => ({...m, northing: e.target.value}))} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                {headers.map((h, i) => <option key={i} value={i}>{h}</option>)}
                            </select>
                            <p className="text-xs text-slate-500 mt-1">معاينة: {getColumnPreview(mappings.northing)}</p>
                        </div>
                        <div>
                            <label className="block text-sm font-medium mb-1">Elevation (Z)</label>
                            <select value={mappings.elevation} onChange={e => setMappings(m => ({...m, elevation: e.target.value}))} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                <option value="-1">-- لا يوجد --</option>
                                {headers.map((h, i) => <option key={i} value={i}>{h}</option>)}
                            </select>
                            <p className="text-xs text-slate-500 mt-1">معاينة: {getColumnPreview(mappings.elevation)}</p>
                        </div>
                        <div>
                            <label className="block text-sm font-medium mb-1">الوصف (Description)</label>
                            <select value={mappings.description} onChange={e => setMappings(m => ({...m, description: e.target.value}))} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                <option value="-1">-- لا يوجد --</option>
                                {headers.map((h, i) => <option key={i} value={i}>{h}</option>)}
                            </select>
                            <p className="text-xs text-slate-500 mt-1">معاينة: {getColumnPreview(mappings.description)}</p>
                        </div>
                    </div>
                    <h3 className="text-lg font-semibold mb-2">معاينة البيانات (أول 5 صفوف)</h3>
                    <div className="overflow-auto border rounded-lg dark:border-slate-600" style={{maxHeight: '200px'}}>
                        <table className="w-full text-sm">
                            <thead className="bg-gray-50 dark:bg-slate-700"><tr className="text-right">{headers.map((h, i) => <th key={i} className="p-2 font-semibold"><div>{`العمود ${i + 1}`}</div><div className="font-normal text-xs">{h}</div></th>)}</tr></thead>
                            <tbody className="dark:bg-slate-800">{dataRows.slice(0, 5).map((row, i) => <tr key={i} className="border-t dark:border-slate-700 text-right">{row.map((cell, j) => <td key={j} className="p-2">{cell}</td>)}</tr>)}</tbody>
                        </table>
                    </div>
                </GenericModal>
            );
        };

        // نافذة منبثقة لتصدير النقاط
        const ExportPointsModal = ({ workAreas, onClose, onExport }) => {
            const { addToast } = useAppContext();
            const [selectedIds, setSelectedIds] = useState({});
            const [exportFormat, setExportFormat] = useState('csv');
            const [delimiter, setDelimiter] = useState(',');
            const [acadScriptType, setAcadScriptType] = useState('pline');
            const [addCsvDescription, setAddCsvDescription] = useState(false);
            const [generatedCommand, setGeneratedCommand] = useState('');
            
            const [fileName, setFileName] = useState('تصدير_نقاط');
            const [fileExtension, setFileExtension] = useState('csv');

            useEffect(() => {
                if (exportFormat === 'csv') {
                    setFileName('تصدير_نقاط');
                } else if (exportFormat === 'acad_script') {
                    setFileName(`سكريبت_${acadScriptType}`);
                    setFileExtension('scr');
                }
            }, [exportFormat, acadScriptType]);

            useEffect(() => {
                if (exportFormat === 'acad_script') {
                    setFileName(`سكريبت_${acadScriptType}`);
                }
            }, [acadScriptType]);

            const handleSelectionChange = (id, type) => {
                setSelectedIds(prev => {
                    const newSelection = { ...prev };
                    if (newSelection[id]) {
                        delete newSelection[id];
                        if (type === 'area') {
                            const area = workAreas.find(a => a.id === id);
                            area?.groups.forEach(g => delete newSelection[`group-${g.id}`]);
                        }
                    } else {
                        newSelection[id] = true;
                        if (type === 'area') {
                            const area = workAreas.find(a => a.id === id);
                            area?.groups.forEach(g => newSelection[`group-${g.id}`] = true);
                        }
                    }
                    return newSelection;
                });
            };

            const handleExportClick = () => {
                if (!fileName || fileName.trim() === '') {
                    addToast('الرجاء إدخال اسم ملف صالح.', 'error');
                    return;
                }
                const options = { selectedIds, exportFormat, delimiter, fileExtension, acadScriptType, addCsvDescription };
                const result = onExport(options, fileName.trim());

                if (exportFormat === 'acad_script') {
                    if (result) {
                        setGeneratedCommand(result);
                    }
                } else {
                    onClose();
                }
            };

            const copyCommandToClipboard = () => {
                if (!generatedCommand) return;
                const textArea = document.createElement("textarea");
                textArea.value = generatedCommand;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    addToast('تم نسخ الأمر إلى الحافظة.', 'success');
                } catch (err) {
                    addToast('فشل النسخ إلى الحافظة.', 'error');
                }
                document.body.removeChild(textArea);
            };

            const handleDownloadScript = () => {
                if (!generatedCommand || !fileName) return;
                downloadFile(generatedCommand, `${fileName.trim()}.scr`, 'application/octet-stream');
                addToast('تم تنزيل ملف السكريبت.', 'success');
            };

            return (
                <GenericModal title="تصدير النقاط" onClose={onClose} onConfirm={handleExportClick} confirmText={exportFormat === 'acad_script' ? 'توليد الأمر' : 'تصدير'}>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h3 className="text-lg font-semibold mb-2">1. تحديد النطاق</h3>
                            <div className="p-2 border rounded-md h-64 overflow-y-auto dark:border-slate-600">
                                {workAreas.map(area => (
                                    <div key={area.id} className="mb-2">
                                        <div className="flex items-center">
                                            <input type="checkbox" id={`area-${area.id}`} checked={!!selectedIds[area.id]} onChange={() => handleSelectionChange(area.id, 'area')} className="ml-2" />
                                            <label htmlFor={`area-${area.id}`} className="font-bold">{area.name}</label>
                                        </div>
                                        <div className="mr-6 mt-1 space-y-1">
                                            {area.groups.map(group => (
                                                <div key={group.id} className="flex items-center">
                                                    <input type="checkbox" id={`group-${group.id}`} checked={!!selectedIds[`group-${group.id}`]} onChange={() => handleSelectionChange(`group-${group.id}`, 'group')} className="ml-2" />
                                                    <label htmlFor={`group-${group.id}`}>{group.name}</label>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div>
                            <h3 className="text-lg font-semibold mb-2">2. تحديد الصيغة والإعدادات</h3>
                            <div className="space-y-2">
                                <div className="flex items-center"><input type="radio" id="format-csv" name="format" value="csv" checked={exportFormat === 'csv'} onChange={e => setExportFormat(e.target.value)} className="ml-2" /><label htmlFor="format-csv">ملف نصي</label></div>
                                <div className="flex items-center"><input type="radio" id="format-acad" name="format" value="acad_script" checked={exportFormat === 'acad_script'} onChange={e => setExportFormat(e.target.value)} className="ml-2" /><label htmlFor="format-acad">سكريبت AutoCAD/Civil</label></div>
                            </div>
                            
                            <div className="mt-4">
                                <label htmlFor="file-name-input" className="block text-sm font-medium mb-1">اسم الملف</label>
                                <div className="flex">
                                    <input 
                                        id="file-name-input"
                                        type="text" 
                                        value={fileName} 
                                        onChange={e => setFileName(e.target.value)} 
                                        className="block w-full p-2 border rounded-r-md dark:bg-slate-700 dark:border-slate-600 focus:ring-2 focus:ring-blue-500" 
                                    />
                                    <span className="inline-flex items-center px-3 rounded-l-md border border-r-0 border-gray-300 bg-gray-50 text-gray-500 text-sm dark:bg-slate-800 dark:border-slate-600 dark:text-slate-400">
                                        .{fileExtension}
                                    </span>
                                </div>
                            </div>
                            
                            {exportFormat === 'csv' && (
                                <div className="mt-4 space-y-4">
                                    <div>
                                        <label htmlFor="delimiter" className="block text-sm font-medium mb-1">الفاصلة</label>
                                        <select id="delimiter" value={delimiter} onChange={e => setDelimiter(e.target.value)} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                            <option value=",">فاصلة (,)</option>
                                            <option value=" ">مسافة (Space)</option>
                                            <option value="\t">تاب (Tab)</option>
                                            <option value=";">فاصلة منقوطة (;)</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label htmlFor="file-extension-select" className="block text-sm font-medium mb-1">نوع الملف</label>
                                        <select id="file-extension-select" value={fileExtension} onChange={e => setFileExtension(e.target.value)} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                            <option value="csv">ملف CSV</option>
                                            <option value="txt">ملف نصي TXT</option>
                                        </select>
                                    </div>
                                    <div className="flex items-center">
                                        <input type="checkbox" id="add-csv-desc" checked={addCsvDescription} onChange={e => setAddCsvDescription(e.target.checked)} className="ml-2" />
                                        <label htmlFor="add-csv-desc">تضمين الوصف (تنسيق P,E,N,Z,D)</label>
                                    </div>
                                </div>
                            )}
                            {exportFormat === 'acad_script' && (
                                <div className="mt-4 space-y-4">
                                    <div>
                                        <label htmlFor="acad-script-type" className="block text-sm font-medium mb-1">نوع السكريبت</label>
                                        <select id="acad-script-type" value={acadScriptType} onChange={e => setAcadScriptType(e.target.value)} className="block w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600">
                                            <option value="pline">خطوط متصلة (Polyline)</option>
                                            <option value="points">نقاط (Points)</option>
                                        </select>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    {generatedCommand && (
                        <div className="mt-4">
                            <h4 className="font-semibold mb-1">الأمر المولد:</h4>
                            <textarea readOnly value={generatedCommand} className="w-full h-24 p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 font-mono text-sm" />
                            <div className="flex items-center gap-2 mt-2">
                                <button onClick={copyCommandToClipboard} className="button-secondary">
                                    <Icon name="copy" size={16} className="inline-block ml-1" />
                                    نسخ الأمر
                                </button>
                                <button onClick={handleDownloadScript} className="button-primary">
                                    <Icon name="download" size={16} className="inline-block ml-1" />
                                    تنزيل ملف .scr
                                </button>
                            </div>
                        </div>
                    )}
                </GenericModal>
            );
        };
        
        // **جديد:** نافذة منبثقة لخيارات لقطة الشاشة
        const ScreenshotOptionsModal = ({ onClose, onConfirm }) => {
            const [showPanel, setShowPanel] = useState(true);
            const [showTimestamp, setShowTimestamp] = useState(true);

            const handleConfirm = () => {
                onConfirm({ showPanel, showTimestamp });
            };

            return (
                <GenericModal title="إعدادات لقطة الشاشة" onClose={onClose} onConfirm={handleConfirm} confirmText="التقاط الصورة">
                    <div className="space-y-4">
                        <div className="flex items-center">
                            <input id="show-panel-check" type="checkbox" checked={showPanel} onChange={e => setShowPanel(e.target.checked)} className="ml-3 h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500" />
                            <label htmlFor="show-panel-check" className="text-base text-slate-700 dark:text-slate-200">إظهار لوحة معلومات المنطقة</label>
                        </div>
                        <div className="flex items-center">
                            <input id="show-timestamp-check" type="checkbox" checked={showTimestamp} onChange={e => setShowTimestamp(e.target.checked)} className="ml-3 h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500" />
                            <label htmlFor="show-timestamp-check" className="text-base text-slate-700 dark:text-slate-200">إظهار الوقت والتاريخ</label>
                        </div>
                    </div>
                </GenericModal>
            );
        };

        // ====================================================================
        //  FILE: src/App.js
        //  هذا هو المكون الرئيسي للتطبيق الذي يجمع كل المكونات الأخرى ويدير الحالة العامة
        // ====================================================================
        function App() {
            // دالة لتهيئة مناطق العمل، إما من التخزين المحلي (localStorage) أو إنشاء منطقة عمل افتراضية
            const initializeWorkAreas = () => {
                try {
                    const saved = localStorage.getItem('workAreas');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            // **تعديل:** ضمان وجود خاصية isVisible للبيانات القديمة
                            return parsed.map(area => ({
                                ...area,
                                groups: area.groups.map(g => ({...DEFAULT_GROUP_SETTINGS, isVisible: g.isVisible !== false, ...g}))
                            }));
                        }
                    }
                } catch (e) { console.error("Failed to load work areas", e); }
                return [{ 
                    id: generateUniqueId(), 
                    name: 'منطقة عمل 1', 
                    createdAt: new Date().toISOString(), 
                    groups: [{ id: generateUniqueId(), name: 'مجموعة نقاط 1', color: POINT_GROUP_COLORS[0], points: [], ...DEFAULT_GROUP_SETTINGS }],
                }];
            };

            // تعريف الحالات (States) الرئيسية للتطبيق
            const [workAreas, setWorkAreas, undo, redo, canUndo, canRedo] = useHistoryState(initializeWorkAreas());
            const [selectedWorkAreaId, setSelectedWorkAreaId] = useState(() => localStorage.getItem('selectedWorkAreaId') || workAreas[0]?.id || null);
            const [selectedGroupId, setSelectedGroupId] = useState(() => localStorage.getItem('selectedGroupId') || null);
            const [activePointId, setActivePointId] = useState(null); // النقطة النشطة حالياً (المحددة على الخريطة أو في الجدول)
            const [isMapFullScreen, setIsMapFullScreen] = useState(false);
            const [isSidebarOpen, setIsSidebarOpen] = useState(false);
            const [isDeleteMode, setIsDeleteMode] = useState(false);
            const [isCoordinatesViewActive, setIsCoordinatesViewActive] = useState(false); // هل جدول الإحداثيات مكبر؟
            const [currentZoom, setCurrentZoom] = useState(DEFAULT_MAP_ZOOM);
            const { utmZone, setUtmZone, addToast, setModal, closeModal, modal } = useAppContext(); // **تصحيح:** إضافة modal
            const mapApiRef = useRef(null); // مرجع للوصول إلى دوال مكون الخريطة
            const [isTakingScreenshot, setIsTakingScreenshot] = useState(false); // **جديد:** حالة لتتبع عملية أخذ لقطة الشاشة
            
            const isZoomedInEnough = currentZoom >= LABEL_VISIBILITY_ZOOM_THRESHOLD;

            // **جديد:** تأثير لإضافة مستمعي أحداث لوحة المفاتيح
            useEffect(() => {
                const handleKeyDown = (event) => {
                    // تجاهل الاختصارات إذا كانت نافذة منبثقة أو حقل إدخال نشط
                    if (modal || ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                        return;
                    }

                    if (event.ctrlKey) {
                        if (event.key.toLowerCase() === 'z') {
                            event.preventDefault();
                            undo();
                        } else if (event.key.toLowerCase() === 'y') {
                            event.preventDefault();
                            redo();
                        }
                    }
                };

                window.addEventListener('keydown', handleKeyDown);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                };
            }, [undo, redo, modal]); // إضافة modal كعامل تبعية

            // تأثير للتعامل مع منطق الاختيار عند تغيير مناطق العمل (مثل حذف منطقة)
            useEffect(() => {
                if (workAreas.length > 0 && !workAreas.some(a => a.id === selectedWorkAreaId)) {
                    const firstAreaId = workAreas[0].id;
                    setSelectedWorkAreaId(firstAreaId);
                    const firstArea = workAreas[0];
                    setSelectedGroupId(firstArea.groups[0]?.id || null);
                } else if (workAreas.length === 0) {
                    setSelectedWorkAreaId(null);
                    setSelectedGroupId(null);
                }
            }, [workAreas, selectedWorkAreaId]);
            
            // استخدام useMemo لتحسين أداء حساب المنطقة والمجموعة المحددة
            const selectedArea = useMemo(() => workAreas.find(a => a.id === selectedWorkAreaId), [workAreas, selectedWorkAreaId]);
            const selectedGroup = useMemo(() => selectedArea?.groups.find(g => g.id === selectedGroupId), [selectedArea, selectedGroupId]);

            // تأثيرات لحفظ الحالة في التخزين المحلي (localStorage) عند تغييرها
            useEffect(() => { localStorage.setItem('workAreas', JSON.stringify(workAreas)); }, [workAreas]);
            useEffect(() => { if (selectedWorkAreaId) localStorage.setItem('selectedWorkAreaId', selectedWorkAreaId); else localStorage.removeItem('selectedWorkAreaId'); }, [selectedWorkAreaId]);
            useEffect(() => { if (selectedGroupId) localStorage.setItem('selectedGroupId', selectedGroupId); else localStorage.removeItem('selectedGroupId'); }, [selectedGroupId]);
            
            // دالة مساعدة لتحديث منطقة عمل معينة
            const updateWorkArea = (areaId, updateFn) => {
                setWorkAreas(prevAreas => prevAreas.map(a => a.id === areaId ? updateFn(a) : a));
            };
            
            // معالج حدث اختيار منطقة عمل
            const handleSelectArea = (areaId) => {
                setSelectedWorkAreaId(areaId);
                const area = workAreas.find(a => a.id === areaId);
                setSelectedGroupId(area?.groups[0]?.id || null);
                setActivePointId(null);
                const allPoints = area?.groups.flatMap(g => g.points) || [];
                if (allPoints.length > 0) {
                    mapApiRef.current?.zoomToBounds(allPoints);
                } else {
                    mapApiRef.current?.resetView();
                }
            };

            // معالج حدث إضافة منطقة عمل جديدة
            const handleAddNewArea = (name) => {
                const newAreaId = generateUniqueId();
                const newGroupId = generateUniqueId();
                const newArea = { 
                    id: newAreaId, 
                    name, 
                    createdAt: new Date().toISOString(),
                    groups: [{ id: newGroupId, name: 'مجموعة نقاط 1', color: POINT_GROUP_COLORS[0], points: [], ...DEFAULT_GROUP_SETTINGS }]
                };
                setWorkAreas(p => [...p, newArea]);
                setSelectedWorkAreaId(newAreaId);
                setSelectedGroupId(newGroupId);
                setActivePointId(null);
                mapApiRef.current?.resetView();
            };
            
            const handleDeleteArea = (id) => { setWorkAreas(p => p.filter(a => a.id !== id)); };
            const handleRenameArea = (id, name) => { updateWorkArea(id, a => ({...a, name})); };

            // معالجات الأحداث الخاصة بمجموعات النقاط
            const handleAddNewGroup = (areaId, name) => {
                const newGroup = {id: generateUniqueId(), name, color: POINT_GROUP_COLORS[workAreas.length % POINT_GROUP_COLORS.length], points:[], ...DEFAULT_GROUP_SETTINGS};
                updateWorkArea(areaId, a => ({...a, groups: [...a.groups, newGroup]}));
                setSelectedGroupId(newGroup.id);
            };
            const handleDeleteGroup = (areaId, groupId) => {
                updateWorkArea(areaId, area => {
                    const newGroups = area.groups.filter(g => g.id !== groupId);
                    if(selectedGroupId === groupId){
                        setSelectedGroupId(newGroups[0]?.id || null);
                        setActivePointId(null);
                    }
                    return {...area, groups: newGroups};
                });
            };
            const handleRenameGroup = (areaId, groupId, name) => {
                 updateWorkArea(areaId, a => ({...a, groups: a.groups.map(g => g.id === groupId ? {...g, name} : g)}));
            };

            // معالج حدث إضافة نقطة جديدة (من الخريطة أو الموقع الحالي)
            const handleAddPoint = useCallback(async (lat, lng) => {
                if (isDeleteMode) { addToast('وضع الحذف مفعل. قم بإلغاء تفعيله لإضافة نقاط.', 'info'); return; }
                if (!selectedArea) { addToast('الرجاء تحديد منطقة عمل أولاً.', 'error'); return; }
                
                let finalLat = lat, finalLng = lng, finalElevation = null, finalUtm = null, snapped = false;
                
                // منطق الالتقاط (Snapping)
                const allPoints = selectedArea.groups.flatMap(g => g.points);
                if (selectedGroup?.snapEnabled && allPoints.length > 0) {
                    const clickLatLng = new window.google.maps.LatLng(lat, lng);
                    const closestPoint = allPoints.reduce((closest, current) => {
                        const distance = window.google.maps.geometry.spherical.computeDistanceBetween(clickLatLng, new window.google.maps.LatLng(current.lat, current.lng));
                        return distance < closest.distance ? { distance, point: current } : closest;
                    }, { distance: Infinity, point: null });

                    if (closestPoint.distance < SNAP_TOLERANCE_METERS) {
                        finalLat = closestPoint.point.lat;
                        finalLng = closestPoint.point.lng;
                        finalElevation = closestPoint.point.elevation;
                        finalUtm = closestPoint.point.utm;
                        snapped = true;
                        addToast('تم الالتقاط إلى نقطة قريبة.', 'info');
                    }
                }

                if (!snapped) {
                    addToast('جاري إضافة النقطة...', 'info');
                    const { elevation, status } = await getElevation({ lat: finalLat, lng: finalLng });
                    if(status !== 'OK') addToast(`فشل جلب المنسوب (${status}). سيتم استخدام قيمة افتراضية.`, 'error', 5000);
                    finalElevation = elevation;
                    finalUtm = convertLatLngToUtm(finalLat, finalLng, utmZone);
                }

                const newPoint = { id: generateUniqueId(), name: '', lat: finalLat, lng: finalLng, elevation: finalElevation ?? 0.00, utm: finalUtm, description: '', markerIcon: 'default', createdAt: new Date().toISOString() };
                
                // إضافة النقطة إلى المجموعة المحددة
                setWorkAreas(prevAreas => {
                    return prevAreas.map(area => {
                        if (area.id !== selectedArea.id) return area;
                        
                        let targetGroupFound = false;
                        const updatedGroups = area.groups.map(g => {
                            if (g.id === selectedGroupId) {
                                targetGroupFound = true;
                                return { ...g, points: [...g.points, newPoint] };
                            }
                            return g;
                        });
                        
                        // إذا لم تكن هناك مجموعة محددة، أضف إلى أول مجموعة
                        if (!targetGroupFound && updatedGroups.length > 0) {
                            updatedGroups[0].points.push(newPoint);
                        } else if (updatedGroups.length === 0) { // إذا لم تكن هناك مجموعات على الإطلاق
                            const newGroupId = generateUniqueId();
                            updatedGroups.push({ id: newGroupId, name: 'مجموعة نقاط 1', color: POINT_GROUP_COLORS[0], points: [newPoint], ...DEFAULT_GROUP_SETTINGS });
                            setSelectedGroupId(newGroupId);
                        }
                        
                        return { ...area, groups: updatedGroups, lastModifiedAt: new Date().toISOString() };
                    });
                });

                if (!snapped) addToast('تمت إضافة النقطة.', 'success');
            }, [selectedArea, selectedGroupId, utmZone, addToast, selectedGroup, setWorkAreas, isDeleteMode]);

            // معالج حدث تحديث بيانات نقطة (بعد السحب أو التعديل في الجدول)
            const handleUpdatePoint = useCallback(async (areaId, groupId, pointId, field, value) => {
                const pointToUpdate = workAreas.find(a => a.id === areaId)?.groups.find(g => g.id === groupId)?.points.find(p => p.id === pointId);
                if (!pointToUpdate) return;
            
                let newPointData = { ...pointToUpdate };
            
                if (field === 'latlng') { // إذا تم تحديث الموقع
                    const { elevation, status } = await getElevation(value);
                    if (status !== 'OK') addToast(`تعذر تحديث المنسوب (${status}). سيتم الاحتفاظ بالمنسوب القديم.`, 'error', 5000);
                    newPointData = { ...newPointData, lat: value.lat, lng: value.lng, utm: convertLatLngToUtm(value.lat, value.lng, utmZone), elevation: elevation ?? newPointData.elevation };
                } else { // إذا تم تحديث حقل آخر (مثل الاسم أو الوصف)
                    newPointData[field] = value;
                }
            
                updateWorkArea(areaId, area => ({ ...area, groups: area.groups.map(g => g.id === groupId ? { ...g, points: g.points.map(p => p.id === pointId ? newPointData : p) } : g) }));
            }, [workAreas, utmZone, addToast, setWorkAreas]);
            
            const handleDeletePointById = (groupId, pointId) => {
                if (!selectedArea) return;
                updateWorkArea(selectedArea.id, a => ({...a, groups: a.groups.map(g => g.id === groupId ? {...g, points: g.points.filter(p => p.id !== pointId)} : g)}));
                addToast('تم حذف النقطة.', 'success');
            };
            
            const handleUpdateGroupColor = (areaId, groupId, color) => {
                updateWorkArea(areaId, area => ({ ...area, groups: area.groups.map(g => g.id === groupId ? {...g, color} : g) }));
            };

            // معالج حدث تحميل ملف
            const handleFileLoad = (file) => {
                const reader = new FileReader();
                const fileName = file.name;

                reader.onload = (e) => {
                    const content = e.target.result;
                    try {
                        if (fileName.endsWith('.hemap')) { // تحميل ملف مشروع
                            const decodedData = decodeURIComponent(escape(atob(content)));
                            const projectData = JSON.parse(decodedData);

                            if (projectData.format !== 'EngineeringMapProject' || !Array.isArray(projectData.workAreas)) {
                                throw new Error('ملف المشروع غير صالح أو تالف.');
                            }
                            
                            setWorkAreas(projectData.workAreas.map(area => ({ ...area, groups: area.groups.map(g => ({...DEFAULT_GROUP_SETTINGS, isVisible: g.isVisible !== false, ...g})) })));
                            setSelectedWorkAreaId(projectData.selectedWorkAreaId);
                            setSelectedGroupId(projectData.selectedGroupId);
                            if (projectData.utmZone) setUtmZone(projectData.utmZone);
                            addToast('تم تحميل المشروع بنجاح.', 'success');
                            
                            // تكبير الخريطة لتناسب المشروع المحمل
                            setTimeout(() => {
                                const loadedArea = projectData.workAreas.find(a => a.id === projectData.selectedWorkAreaId);
                                const allPoints = loadedArea?.groups.flatMap(g => g.points) || [];
                                 if (allPoints.length > 0) mapApiRef.current?.zoomToBounds(allPoints);
                            }, 200);

                        } else if (fileName.endsWith('.json')) { // تحميل ملف JSON قديم
                            const projectData = JSON.parse(content);
                            const dataToLoad = projectData.workAreas ? projectData.workAreas : projectData;
                            if (!Array.isArray(dataToLoad)) throw new Error('صيغة ملف JSON غير معروفة.');
                            setWorkAreas(dataToLoad.map(area => ({ ...area, groups: area.groups.map(g => ({...DEFAULT_GROUP_SETTINGS, isVisible: g.isVisible !== false, ...g})) })));
                            addToast('تم تحميل مشروع JSON بنجاح.', 'success');
                        } else { // تحميل ملف نصي (CSV/TXT)
                            if (!selectedArea) { addToast('الرجاء تحديد منطقة عمل أولاً لاستيراد النقاط.', 'error'); return; }
                            const parsedData = parseDelimitedText(content);
                            if (parsedData.error && !parsedData.data.length) { addToast(parsedData.error, 'error'); return; }
                            setModal(<ImportPointsModal fileData={{...parsedData, fileName}} onClose={closeModal} onImport={handleProcessImport} utmZone={utmZone} />);
                        }
                    } catch (err) {
                        console.error("File load error:", err);
                        addToast(`فشل في تحميل الملف: ${err.message}`, 'error');
                    }
                };
                reader.onerror = () => addToast('فشل في قراءة الملف.', 'error');
                reader.readAsText(file, 'UTF-8');
            };
            
            // معالج إتمام عملية الاستيراد من النافذة المنبثقة
            const handleProcessImport = (groupName, points) => {
                const newGroup = { id: generateUniqueId(), name: groupName, color: POINT_GROUP_COLORS[workAreas.length % POINT_GROUP_COLORS.length], points, ...DEFAULT_GROUP_SETTINGS };
                updateWorkArea(selectedArea.id, area => ({ ...area, groups: [...area.groups, newGroup], lastModifiedAt: new Date().toISOString() }));
                addToast(`تم استيراد ${points.length} نقطة بنجاح إلى "${groupName}".`, 'success');
                setSelectedGroupId(newGroup.id);
                setTimeout(() => mapApiRef.current?.zoomToBounds(points), 100);
            };

            // معالج إتمام عملية اللصق المباشر
            const handleProcessDirectPaste = (points) => {
                if (!selectedArea || !selectedGroup) return;
                updateWorkArea(selectedArea.id, area => ({ ...area, groups: area.groups.map(g => g.id === selectedGroup.id ? { ...g, points: [...g.points, ...points] } : g), lastModifiedAt: new Date().toISOString() }));
                addToast(`تم إضافة ${points.length} نقطة بنجاح.`, 'success');
                setTimeout(() => mapApiRef.current?.zoomToBounds(points), 100);
            };

            const handleOpenDirectPasteModal = () => {
                if (!selectedArea || !selectedGroup) { addToast('الرجاء تحديد منطقة عمل ومجموعة نقاط أولاً.', 'error'); return; }
                setModal(<DirectPasteModal onClose={closeModal} onProcessPaste={handleProcessDirectPaste} utmZone={utmZone} />);
            };
            
            // معالج عملية تصدير البيانات
            const handleExportData = (options, fileNameFromModal) => {
                const { selectedIds, exportFormat, delimiter, fileExtension, acadScriptType, addCsvDescription } = options;
                
                const selectedGroups = workAreas.flatMap(area => 
                    area.groups.filter(group => selectedIds[area.id] || selectedIds[`group-${group.id}`])
                );

                const pointsToExport = selectedGroups.flatMap(g => g.points)
                    .filter(p => p && p.utm && typeof p.utm.easting === 'number' && typeof p.utm.northing === 'number');

                if (pointsToExport.length === 0) {
                    addToast('لم يتم تحديد نقاط صالحة للتصدير.', 'error');
                    return null;
                }

                const safeToFixed = (num, digits = 3) => (typeof num === 'number' ? num.toFixed(digits) : '0.000');
                
                let content = '';
                
                if (exportFormat === 'csv') {
                    content = pointsToExport.map((p, index) => {
                        const base = `${safeToFixed(p.utm.easting)}${delimiter}${safeToFixed(p.utm.northing)}${delimiter}${safeToFixed(p.elevation)}`;
                        return addCsvDescription ? `${index + 1}${delimiter}${base}${delimiter}${p.description || ''}` : base;
                    }).join('\n');
                    
                    const finalFileName = `${fileNameFromModal}.${fileExtension}`;
                    const mimeType = fileExtension === 'csv' ? 'text/csv' : 'text/plain';
                    downloadFile(content, finalFileName, mimeType);
                    return null; // Download is handled
                } 
                else if (exportFormat === 'acad_script') {
                    if (acadScriptType === 'pline') {
                        content = selectedGroups.map(group => 
                            "PLINE\n" + group.points.map(p => `${safeToFixed(p.utm?.easting)},${safeToFixed(p.utm?.northing)}`).join('\n')
                        ).join('\n \n');
                    } else { // points
                        content = pointsToExport.map(p => 
                            `_POINT ${safeToFixed(p.utm?.easting)},${safeToFixed(p.utm?.northing)},${safeToFixed(p.elevation)}`
                        ).join('\n');
                    }
                    return content; // Return script content for the modal
                }

                return null;
            };

            // معالج طلب الموقع الحالي
            const triggerGetCurrentLocation = async () => {
                if (!selectedArea) { addToast('الرجاء تحديد منطقة عمل أولاً.', 'error'); return; }
                addToast('جاري جلب موقعك الحالي...', 'info');
                const { location, error } = await getCurrentLocation();
                if (location) await handleAddPoint(location.lat, location.lng);
                else addToast(error.message, 'error', 5000);
            };
            
            const handleToggleDeleteMode = () => {
                setIsDeleteMode(prev => {
                    const newMode = !prev;
                    if (newMode) addToast('وضع الحذف مفعل. انقر على أي نقطة لحذفها.', 'info', 4000);
                    else addToast('تم إلغاء تفعيل وضع الحذف.', 'info', 4000);
                    return newMode;
                });
            };

            // **تعديل:** تحديث منطق إعدادات المجموعة
            const handleUpdateGroupSettings = (settingKey, value) => {
                if (!selectedGroupId || !selectedArea) return;
                updateWorkArea(selectedArea.id, area => ({
                    ...area,
                    groups: area.groups.map(g => {
                        if (g.id === selectedGroupId) {
                            const newSettings = { ...g, [settingKey]: value };
                            // إذا تم تغيير محتوى التسمية وكانت التسميات مخفية، قم بإظهارها
                            if (settingKey === 'labelContent' && !g.showLabels) {
                                newSettings.showLabels = true;
                            }
                            return newSettings;
                        }
                        return g;
                    })
                }));
            };

            // **جديد:** معالج تبديل رؤية الطبقة
            const handleToggleGroupVisibility = (areaId, groupId) => {
                updateWorkArea(areaId, area => ({
                    ...area,
                    groups: area.groups.map(g => 
                        g.id === groupId ? { ...g, isVisible: !g.isVisible } : g
                    )
                }));
            };
            
            // **جديد:** معالج لتغيير رمز كل النقاط في مجموعة
            const handleSetGroupMarker = (areaId, groupId, iconKey) => {
                updateWorkArea(areaId, area => ({
                    ...area,
                    groups: area.groups.map(g => {
                        if (g.id === groupId) {
                            return {
                                ...g,
                                points: g.points.map(p => ({ ...p, markerIcon: iconKey }))
                            };
                        }
                        return g;
                    })
                }));
                addToast('تم تحديث رموز المجموعة بنجاح.', 'success');
            };

            // حساب إعدادات العرض للمجموعة الحالية
            const displaySettings = useMemo(() => {
                if(selectedGroup) return { ...DEFAULT_GROUP_SETTINGS, ...selectedGroup };
                return DEFAULT_GROUP_SETTINGS;
            }, [selectedGroup]);

            const promptAction = (title, message, inputLabel, initialValue, onConfirm) => {
                setModal(<GenericModal type="prompt" title={title} message={message} inputLabel={inputLabel} initialValue={initialValue} onConfirm={onConfirm} onClose={closeModal} />);
            };

            // معالج حفظ المشروع بالكامل
            const handleSaveProject = () => {
                promptAction("حفظ المشروع", "أدخل اسم الملف:", "اسم الملف", "مشروعي_الهندسي", (fileName) => {
                    if (!fileName || fileName.trim() === '') { addToast('تم إلغاء الحفظ. اسم الملف فارغ.', 'error'); return; }

                    const projectData = {
                        format: 'EngineeringMapProject', version: '1.2.0', savedAt: new Date().toISOString(),
                        workAreas: workAreas, selectedWorkAreaId: selectedWorkAreaId, selectedGroupId: selectedGroupId, utmZone: utmZone
                    };

                    const jsonString = JSON.stringify(projectData, null, 2);
                    const encodedData = btoa(unescape(encodeURIComponent(jsonString))); // ترميز خاص لضمان سلامة البيانات

                    downloadFile(encodedData, `${fileName.trim()}.hemap`, 'application/octet-stream');
                    addToast('تم حفظ المشروع بنجاح.', 'success');
                });
            };

            // **تعديل:** دالة فتح نافذة خيارات لقطة الشاشة
            const handleOpenScreenshotModal = () => {
                setModal(
                    <ScreenshotOptionsModal
                        onClose={closeModal}
                        onConfirm={(options) => {
                            closeModal();
                            // تأخير بسيط لضمان إغلاق النافذة قبل التقاط الصورة
                            setTimeout(() => executeScreenshot(options), 100);
                        }}
                    />
                );
            };

            // **تعديل:** دالة تنفيذ أخذ لقطة الشاشة مع الخيارات
            const executeScreenshot = (options) => {
                const captureArea = document.getElementById('capture-area');
                if (!captureArea) return;

                const elementsToHide = [
                    document.getElementById('floating-toolbar'),
                    document.getElementById('history-controls'),
                ];
                
                const timestamp = document.createElement('div');
                timestamp.id = 'temp-timestamp';
                timestamp.className = 'absolute bottom-4 right-4 z-10 bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm p-2 px-4 rounded-lg shadow-lg border dark:border-slate-700 text-sm font-mono';
                timestamp.innerText = new Date().toLocaleString('ar-EG', { dateStyle: 'medium', timeStyle: 'short' });

                // --- Prepare UI for screenshot ---
                setIsTakingScreenshot(true);
                elementsToHide.forEach(el => { if (el) el.style.visibility = 'hidden'; });

                if (!options.showPanel) {
                    const panel = document.getElementById('active-area-indicator');
                    if (panel) panel.style.visibility = 'hidden';
                }
                
                if (options.showTimestamp) {
                    captureArea.appendChild(timestamp);
                }
                
                addToast('جاري أخذ لقطة شاشة...', 'info', 2000);

                // --- Take screenshot ---
                html2canvas(captureArea, {
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: null,
                }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `خريطة-${new Date().toISOString().slice(0, 10)}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    addToast('تم حفظ لقطة الشاشة بنجاح.', 'success');
                }).catch(err => {
                    console.error("Screenshot error:", err);
                    addToast('فشل أخذ لقطة الشاشة.', 'error');
                }).finally(() => {
                    // --- Cleanup UI after screenshot ---
                    elementsToHide.forEach(el => { if (el) el.style.visibility = 'visible'; });
                    const panel = document.getElementById('active-area-indicator');
                    if (panel) panel.style.visibility = 'visible';

                    if (document.getElementById('temp-timestamp')) {
                        document.getElementById('temp-timestamp').remove();
                    }
                    setIsTakingScreenshot(false);
                });
            };
            
            // العرض النهائي للتطبيق (JSX)
            return (
                <div className="h-screen w-screen flex flex-col bg-slate-100 dark:bg-slate-900">
                    <Header onToggleFullScreen={() => setIsMapFullScreen(f => !f)} isFullScreen={isMapFullScreen} onToggleSidebar={() => setIsSidebarOpen(o => !o)} />
                    <div className="flex flex-grow overflow-hidden">
                        <Sidebar 
                            isOpen={isSidebarOpen}
                            onClose={() => setIsSidebarOpen(false)}
                            workAreas={workAreas} 
                            selectedAreaId={selectedWorkAreaId}
                            selectedGroupId={selectedGroupId}
                            onSelectArea={handleSelectArea}
                            onSelectGroup={setSelectedGroupId}
                            onAddNewArea={handleAddNewArea}
                            onRenameArea={handleRenameArea}
                            onDeleteArea={handleDeleteArea}
                            onFileLoad={handleFileLoad}
                            onZoomToWorkArea={id => mapApiRef.current?.zoomToBounds(workAreas.find(a=>a.id===id)?.groups.flatMap(g=>g.points))}
                            onGetCurrentLocation={triggerGetCurrentLocation}
                            onAddNewGroup={handleAddNewGroup}
                            onRenameGroup={handleRenameGroup}
                            onDeleteGroup={handleDeleteGroup}
                            onZoomToGroup={(areaId, groupId) => {
                                const group = workAreas.find(a => a.id === areaId)?.groups.find(g => g.id === groupId);
                                if (group && group.points.length > 0) {
                                    mapApiRef.current?.zoomToBounds(group.points);
                                } else if (group) {
                                    addToast(`مجموعة "${group.name}" فارغة، لا يمكن التقريب.`, 'info');
                                }
                            }}
                            onUpdateGroupColor={handleUpdateGroupColor}
                            onOpenExportModal={() => setModal(<ExportPointsModal workAreas={workAreas} onClose={closeModal} onExport={handleExportData} />)}
                            onSaveProject={handleSaveProject}
                            onOpenDirectPasteModal={handleOpenDirectPasteModal}
                            onToggleGroupVisibility={handleToggleGroupVisibility}
                            onSetGroupMarker={handleSetGroupMarker}
                        />
                        <main className="flex-grow flex flex-col">
                           <div id="capture-area" className="flex-grow relative">
                                <MapComponent
                                    ref={mapApiRef}
                                    selectedArea={selectedArea}
                                    selectedGroupId={selectedGroupId}
                                    utmZone={utmZone}
                                    onAddPoint={handleAddPoint}
                                    onUpdatePoint={handleUpdatePoint}
                                    onUpdateGroupSettings={handleUpdateGroupSettings}
                                    onActivateGroup={setSelectedGroupId}
                                    setActivePointId={setActivePointId}
                                    addToast={addToast}
                                    isDeleteMode={isDeleteMode}
                                    onDeletePointById={handleDeletePointById}
                                    onZoomChange={setCurrentZoom}
                                />
                                {selectedArea && (
                                    <>
                                        <HistoryControls undo={undo} redo={redo} canUndo={canUndo} canRedo={canRedo} />
                                        <ActiveAreaIndicator 
                                            areaName={selectedArea?.name} 
                                            groupName={selectedGroup?.name} 
                                            isTakingScreenshot={isTakingScreenshot}
                                        />
                                        <FloatingToolbar 
                                            settings={displaySettings}
                                            onUpdateSettings={handleUpdateGroupSettings}
                                            onAddPointFromCurrentLocation={triggerGetCurrentLocation}
                                            isDeleteMode={isDeleteMode}
                                            onToggleDeleteMode={handleToggleDeleteMode}
                                            isZoomedInEnough={isZoomedInEnough}
                                            onTakeScreenshot={handleOpenScreenshotModal}
                                        />
                                    </>
                                )}
                            </div>
                            {!isMapFullScreen && (
                                <div className={`flex-shrink-0 border-t-2 dark:border-slate-700 transition-all duration-300 ease-in-out ${isCoordinatesViewActive ? 'h-5/6' : 'h-1/3'} flex flex-col`}>
                                    <div className="flex-shrink-0 p-2 flex justify-center items-center border-b dark:border-slate-700 bg-slate-100 dark:bg-slate-800/50">
                                        <button
                                            onClick={() => setIsCoordinatesViewActive(p => !p)}
                                            className={`font-bold py-2 px-8 rounded-lg shadow-md transition-all duration-300 flex items-center gap-2 ${isCoordinatesViewActive ? 'bg-blue-600 text-white scale-105' : 'bg-white dark:bg-slate-700'}`}
                                            title={isCoordinatesViewActive ? 'تصغير جدول الإحداثيات' : 'تكبير جدول الإحداثيات'}
                                        >
                                            <Icon name="list-ordered" />
                                            إحداثيات
                                        </button>
                                    </div>
                                    <div className="flex-grow overflow-auto">
                                        <PointsTable 
                                            selectedArea={selectedArea} 
                                            selectedGroupId={selectedGroupId}
                                            onUpdatePoint={handleUpdatePoint}
                                            onDeletePoint={handleDeletePointById}
                                            onActivateGroup={setSelectedGroupId}
                                            activePointId={activePointId}
                                            setActivePointId={setActivePointId}
                                            onZoomToPoint={(areaId, groupId, pointId) => {
                                                const point = workAreas.find(a=>a.id===areaId)?.groups.find(g=>g.id===groupId)?.points.find(p=>p.id===pointId);
                                                if(point) mapApiRef.current?.zoomToPoint(point.lat, point.lng);
                                            }}
                                        />
                                    </div>
                                </div>
                            )}
                        </main>
                    </div>
                </div>
            );
        }

        // ====================================================================
        //  FILE: src/main.js (Entry Point)
        //  نقطة البداية لتشغيل التطبيق
        // ====================================================================
        const container = document.getElementById('root');
        const root = createRoot(container);
        
        // هذه الدالة يتم استدعاؤها بواسطة Google Maps API بعد تحميل المكتبة بنجاح
        window.initMap = () => root.render(
            <AppProvider>
                <App />
            </AppProvider>
        );
        
        // في حالة كانت مكتبة خرائط جوجل محملة بالفعل، قم بتشغيل التطبيق فوراً
        if (window.google && window.google.maps) window.initMap();

    </script>
</body>
</html>
